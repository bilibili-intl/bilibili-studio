; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
#define kInputDir           GetEnv('INNO_INPUT_DIR')
#define kLicenseFile        GetEnv('INNO_LICENSE_FILE')
#define kOutputDir          GetEnv('INNO_OUTPUT_DIR')
#define kOutputFileName     GetEnv('INNO_OUTPUT_FILENAME')
#define kInstallerIconFile  GetEnv('INNO_OUTPUT_FILEICON')
#define kSetupResDir        GetEnv('INNO_SETUP_RES_DIR')

#define kAppId           "{81F6F736-F774-4965-A593-1AFD31ABBB35}"
#define kAppName         "哔哩哔哩直播姬"
#define kAppVersion      GetEnv('INNO_APP_VERSION')
#define kAppPublisher    "上海幻电信息科技有限公司"
#define kAppURL          "https://www.bilibili.com/"
#define kAppExeName      "livehime.exe"
#define kFWRuleName      "Bililive Screencast"

#define kBililiveOBSPluginName      "bililive_obs_plugin.dll"

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{#kAppId}
AppName={#kAppName}
AppVersion={#kAppVersion}
AppPublisher={#kAppPublisher}
AppPublisherURL={#kAppURL}
AppSupportURL={#kAppURL}
AppUpdatesURL={#kAppURL}
DefaultDirName={commonpf}\bililive\livehime
DisableDirPage=no
DisableProgramGroupPage=yes
LicenseFile={#kLicenseFile}
OutputDir={#kOutputDir}
OutputBaseFilename={#kOutputFileName}
Compression=lzma2
SolidCompression=yes
AppMutex="E82991C9-BFF7-4F93-B6FE-E05D9EB71ADF"
VersionInfoCompany="上海幻电信息科技有限公司"
VersionInfoCopyright="Copyright (C) 2016 上海幻电信息科技有限公司. All Right Reserved."
VersionInfoDescription="{#kAppName} 安装程序"
VersionInfoVersion={#kAppVersion}
VersionInfoTextVersion={#kAppVersion}
SetupIconFile={#kInstallerIconFile}
SetupLogging=yes
UsePreviousAppDir=no
UninstallDisplayIcon={app}\{#kAppExeName}
UninstallDisplayName={#kAppName}

[Languages]
Name: "chinesesimplified"; MessagesFile: "compiler:Languages\ChineseSimplified.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: exclusive
Name: "quicklaunchicon"; Description: "{cm:CreateQuickLaunchIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked; OnlyBelowVersion: 0,6.1

[Registry]
Root: HKCR; Subkey: "livehime"; ValueType: string; ValueName: "URL Protocol"; ValueData: ""; Flags: uninsdeletekey
Root: HKCR; Subkey: "livehime\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: """{app}\{#kAppExeName},1"""; Flags: uninsdeletekey
Root: HKCR; Subkey: "livehime\Shell\Open\command"; ValueType: string; ValueName: ""; ValueData: """{app}\{#kAppExeName}"" --livehime-type=scheme --scheme=""%1"""; Flags: uninsdeletekey

[code]
var
    g_installed_app_version: String;
	g_installed_boolean: Boolean;

function IsWindows7(): Boolean;
var
    os_ver: TWindowsVersion;
begin
    Result := False;
    GetWindowsVersionEx(os_ver);
    if (os_ver.Major = 6) and (os_ver.Minor = 1) then begin
        Result := True;
    end;
end;

function ShouldCopyFile(): Boolean;
var
    filename: String;
begin
    Result := True;
    // 封包的源数据中，不要有空的目录，否则启动时CurrentFileName()会报错，这应该是inno setup的bug
    // An attempt was made to call the "CurrentFilename" function from outside a "Check", "BeforeInstall" or "AfterInstall" event function belonging to a "[Files]" entry.'
    filename := ExtractFileName(CurrentFileName());
    if (filename = 'D3DCompiler_43.dll') and not IsWindows7() then begin
        Result := False;
        Log('Skip copying ' + filename);
    end;
end;

// 立即安装注入配置标识
procedure InstallClickFlag(bIs:Boolean);
var
    mark_file_path : String;
begin
    // 立即安装注入配置标识
    mark_file_path := ExpandConstant('{localappdata}\Temp\');
	//如果没有安装过，才注入配置标识
    if not g_installed_boolean then begin
	  if bIs = true then begin
        SaveStringToFile(mark_file_path + 'livehime_install_click', '1', False);
      end else begin
        SaveStringToFile(mark_file_path + 'livehime_install_click', '0', False);
      end;
	end;
    
end;

// 立即体验注入配置标识
procedure RunClickFlag(bIs:Boolean);
var
    mark_file_path : String;
begin
    //如果没有安装过，才注入配置标识
    mark_file_path := ExpandConstant('{localappdata}\Temp\');
    if not g_installed_boolean then begin
	  if bIs = true then begin
         SaveStringToFile(mark_file_path + 'livehime_run_click', '1', False);
      end else begin
         SaveStringToFile(mark_file_path + 'livehime_run_click', '0', False);
      end;
	end;
end;


// 获取应用路径的父路径，即不带版本号的路径
function GetAppParentFolder(Param: String) : String;
begin
    Result := ExtractFilePath(ExpandConstant('{app}'));
end;

// 当前已安装的直播姬版本号（读注册表）。如果当前未安装，则返回空字符串
function GetInstalledAppVersion(Param: String) : String;
begin
    Result := g_installed_app_version;
end;

[Files]
Source: "{#kInputDir}\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs; Check: ShouldCopyFile()
Source: "{#kSetupResDir}\InnoCallBack.dll"; DestDir: {tmp}; Flags: dontcopy
Source: "{#kSetupResDir}\botva2.dll"; DestDir: {tmp}; Flags: dontcopy
Source: res\*; DestDir: {tmp}; Flags: dontcopy solidbreak ; Attribs: hidden system

[Icons]
Name: "{commonprograms}\{#kAppName}\{#kAppName}"; Filename: "{app}\..\{#kAppExeName}"; IconFilename: "{app}\{#kAppExeName}"
Name: "{commonprograms}\{#kAppName}\卸载{#kAppName}"; Filename: "{app}\unins000.exe"
Name: "{commondesktop}\{#kAppName}"; Filename: "{app}\..\{#kAppExeName}"; IconFilename: "{app}\{#kAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#kAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(kAppName, '&', '&&')}}"; Flags: nowait shellexec postinstall skipifsilent
//Filename: "{app}\vcredist_x86.exe"; Parameters: "/c /install /quiet /norestart /log livehime.log"; Check: CheckVCRT; StatusMsg: "正在安装 Microsoft Visual C++ 2013 Redistributable Package (x86)"; Flags: waituntilterminated runascurrentuser
// 用vs2017的runtime
Filename: "{app}\vc_redist.x86.exe"; Parameters: "/c /install /quiet /norestart /log  {tmp}\livehime_vc_redist.log"; Check: CheckVCRT; StatusMsg: "正在安装 Microsoft Visual C++ 2015~2019 Redistributable Package (x86)"; Flags: nowait runascurrentuser
// 先把原来添加的防火墙规则删掉
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{code:GetInstalledAppVersion}\{#kAppExeName}"" protocol=tcp"; Flags: waituntilterminated runhidden skipifdoesntexist
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{#kAppExeName}"" protocol=tcp"; Flags: waituntilterminated runhidden skipifdoesntexist
// 添加防火墙规则
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall add rule name=""{#kFWRuleName}"" dir=in program=""{app}\{#kAppExeName}"" protocol=tcp action=allow"; Flags: nowait runhidden skipifdoesntexist
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall add rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{#kAppExeName}"" protocol=tcp action=allow"; Flags: nowait runhidden skipifdoesntexist

[UninstallRun]
// 删除防火墙规则
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{app}\{#kAppExeName}"" protocol=tcp"; Flags: nowait runhidden skipifdoesntexist
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{#kAppExeName}"" protocol=tcp"; Flags: nowait runhidden skipifdoesntexist

[Code]
type
  TBtnEventProc = procedure(h:HWND);
  TPBProc = function(h:hWnd; Msg, wParam, lParam:Longint):Longint;
  TTimerProc = procedure(h:longword; msg:longword; idevent:longword; dwTime:longword);

// innocallback.dll //////////////////////////////////////////////////////////////////
function  WrapTimerProc(callback: TTimerProc; Paramcount: Integer): Longword;
    external 'wrapcallback@files:innocallback.dll stdcall';
function  WrapBtnCallback(Callback: TBtnEventProc; ParamCount: Integer): Longword;
    external 'wrapcallback@{tmp}\innocallback.dll stdcall delayload';
function  PBCallBack(P:TPBProc;ParamCount:integer):LongWord;
    external 'wrapcallback@files:innocallback.dll stdcall';

// botva2.dll //////////////////////////////////////////////////////////////////
function  ImgLoad(Wnd :HWND; FileName :PAnsiChar; Left, Top, Width, Height :integer; Stretch, IsBkg :boolean) :Longint;
    external 'ImgLoad@{tmp}\botva2.dll stdcall delayload';
procedure ImgApplyChanges(h:HWND);
    external 'ImgApplyChanges@{tmp}\botva2.dll stdcall delayload';
procedure ImgSetPosition(img :Longint; NewLeft, NewTop, NewWidth, NewHeight :integer);
    external 'ImgSetPosition@files:botva2.dll stdcall';
procedure ImgSetVisiblePart(img:Longint; NewLeft, NewTop, NewWidth, NewHeight : integer);
    external 'ImgSetVisiblePart@files:botva2.dll stdcall';
procedure ImgRelease(img :Longint);
    external 'ImgRelease@{tmp}\botva2.dll stdcall delayload';
procedure gdipShutdown;
    external 'gdipShutdown@{tmp}\botva2.dll stdcall delayload';
function  BtnCreate(hParent:HWND; Left,Top,Width,Height:integer; FileName:PAnsiChar; ShadowWidth:integer; IsCheckBtn:boolean):HWND;
    external 'BtnCreate@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetVisibility(h:HWND; Value:boolean);
    external 'BtnSetVisibility@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetEvent(h:HWND; EventID:integer; Event:Longword);
    external 'BtnSetEvent@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetEnabled(h:HWND; Value:boolean);
    external 'BtnSetEnabled@{tmp}\botva2.dll stdcall delayload';
function  BtnGetChecked(h:HWND):boolean;
    external 'BtnGetChecked@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetChecked(h:HWND; Value:boolean);
    external 'BtnSetChecked@{tmp}\botva2.dll stdcall delayload';

// user32.dll //////////////////////////////////////////////////////////////////
function  SetWindowLong(Wnd: HWnd; Index: Integer; NewLong: Longint): Longint;
    external 'SetWindowLongW@user32.dll stdcall';
function  CallWindowProc(lpPrevWndFunc: Longint; hWnd: HWND; Msg: UINT; wParam, lParam: Longint): Longint;
    external 'CallWindowProcW@user32.dll stdcall';
function  ReleaseCapture(): Longint;
    external 'ReleaseCapture@user32.dll stdcall';
function  SetWindowRgn(hWnd: HWND; hRgn: THandle; bRedraw: Boolean): Integer;
    external 'SetWindowRgn@user32.dll stdcall';

// gdi32.dll //////////////////////////////////////////////////////////////////
function  CreateRoundRectRgn(p1, p2, p3, p4, p5, p6: Integer): THandle;
    external 'CreateRoundRectRgn@gdi32 stdcall';

// kernel32.dll //////////////////////////////////////////////////////////////////
procedure ExitProcess(uExitCode: UINT);
    external 'ExitProcess@kernel32.dll stdcall';
function WaitForSingleObject(hHandle: THandle; dwMilliseconds: DWORD): DWORD;
    external 'WaitForSingleObject@kernel32.dll stdcall';
function GetLastError(): DWORD;
    external 'GetLastError@kernel32.dll stdcall';
function CreateMutexRaw(MutexAttributes: LongInt; InitialOwner: Boolean; Name: String): THandle;
    external 'CreateMutexW@kernel32.dll stdcall';
function CloseHandle(hdl: THandle): Boolean;
    external 'CloseHandle@kernel32.dll stdcall';

//////////////////////////////////////////////////////////////////
const
    bgW = 604;
    bgH = 394;
    licenseViewH = 285;
    licenseViewW = 500;
    Radius = 0;
    BtnClickEventID = 1;
    BN_CLICKED = 0;
    WM_COMMAND = $0111;
    WM_SYSCOMMAND = $0112;
    WM_LBUTTONDOWN = $201;
    CN_BASE = $BC00;
    CN_COMMAND = CN_BASE + WM_COMMAND;
    HTCAPTION = 2;
    SC_MOVE = $F010;
    SC_MINIMIZE = $F020;
    kSetupSelfMutex = '{8EA48A84-C18C-4958-9C37-2C01188F8ED0}';        // 安装包自互斥
    kSetupRejectAppMutex = '{915299E6-E1EF-4328-B0C3-0A58D8F54AC7}';   // 直播姬检测安装包的互斥
    kInstanceRunningMutex = '{9FD4ED93-D289-45CA-AED7-4BCF99C7483C}';  // 安装包检测直播姬的互斥
    kLiveHimeUninstallEntryRegPath = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{#kAppId}_is1';
    kLiveHimeOldUninstallEntryRegPath = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{#kAppId}';
    wbemFlagForwardOnly = $00000020;

var
    bgImg, licenseImg, welcomeTVImg, installingTVImg, pathEditImg, installDirImg, progressImg, progressImgBg, installingTipImg, progressProc: Longint;
    licenseBtn, readLicenseBtn, licenseBackBtn, minBtn, cancelBtn, browseBtn, setupBtn: HWND;
    pathEdit: TEdit;
    licenseView: TRichEditViewer;
    licenseViewClose: Boolean;
    licenseCheck, startLiveHimeCheck, injectOBSPluginCheck, setupCompleteBtn: HWND;
    g_update_mode: Boolean;
    g_old_version_install_dir, g_dpi_suffix: String;
    g_dpi_scale: Single;
    g_is_high_dpi: Boolean;
    g_app_reject_mutex: THandle;

procedure cancelBtnClick(hBtn:HWND);
begin
    WizardForm.CancelButton.OnClick(WizardForm);
end;

procedure minBtnClick(hBtn:HWND);
begin
    SendMessage(WizardForm.Handle, WM_SYSCOMMAND, SC_MINIMIZE, 0);
end;

procedure WizardMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
    ReleaseCapture();
    SendMessage(WizardForm.Handle, WM_SYSCOMMAND, SC_MOVE + HTCAPTION, 0);
end;

procedure CloseAppRejectMutex();
begin
    if not (g_app_reject_mutex = 0) then begin
        CloseHandle(g_app_reject_mutex);
        g_app_reject_mutex := 0;
    end;
end;

function GetUninstallRegEntry(entry_name: String; var entry_value: String): Boolean;
begin
	if RegQueryStringValue(HKEY_LOCAL_MACHINE, kLiveHimeUninstallEntryRegPath, entry_name, entry_value) then begin
		Result := True;
	end else begin	
		if RegQueryStringValue(HKEY_LOCAL_MACHINE, kLiveHimeOldUninstallEntryRegPath, entry_name, entry_value) then begin
			Result := True;
		end else begin
			Result := False;
			entry_value := ''
		end;
	end;
end;

procedure RemoveOldUninstallEntry();
begin
	RegDeleteKeyIncludingSubkeys(HKEY_LOCAL_MACHINE, kLiveHimeOldUninstallEntryRegPath);
end;

// 创建或删除OBS插件注入配置标识
procedure CreateOrRemoveObsInjectFlag(bCreate:Boolean);
var
    mark_file_path : String;
begin
    // OBS插件注入与否的配置标识，由安装包生成或直播姬主程序生成
    mark_file_path := ExpandConstant('{localappdata}\Temp\');
    
    if bCreate = true then begin
        SaveStringToFile(mark_file_path + 'Inject_OBS', '', False);
    end else begin
        // 删掉标识文件
        DeleteFile(mark_file_path);
    end;
end;


// 获取OBS的安装路径
function GetOBSStudioInstallPath(): String;
var
    InstallDirKey64: String;
    InstallDirKey32: String;
    LastInstallKey64: String;
    LastInstallKey32: String;
    ObsInstallDir: String;
begin
    Result := '';
    // 最近一次安装的OBS版本信息
    //LastInstallKey64 := 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\OBS Studio';
    //LastInstallKey32 := 'SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\OBS Studio';
    // 32位和64位OBS的共同安装路径
    //InstallDirKey32 := 'SOFTWARE\WOW6432Node\OBS Studio';
    InstallDirKey64 := 'SOFTWARE\OBS Studio';
    if RegQueryStringValue(HKEY_LOCAL_MACHINE, InstallDirKey64, '', ObsInstallDir) then begin
        Log('OBS Studio install dir -> ' + ObsInstallDir);
        Result := ObsInstallDir;
    end else
        Log('Cannot find OBS Studio install dir in the reg -> ' + InstallDirKey64);
end;

// 从OBS的安装路径移除直播姬的OBS插件
procedure EraseBililiveOBSPlugins();
var
    ObsInstallDir: String;
    dst_dll_x86: String;
    dst_dll_x64: String;
begin
    ObsInstallDir := GetOBSStudioInstallPath();
    if ObsInstallDir <> '' then begin
        dst_dll_x86 := ExpandConstant(ObsInstallDir + '\obs-plugins\32bit\{#kBililiveOBSPluginName}');
        dst_dll_x64 := ExpandConstant(ObsInstallDir + '\obs-plugins\64bit\{#kBililiveOBSPluginName}');
        
        Log('delete bililive plugin -> "' + dst_dll_x86 + '"');
        DeleteFile(dst_dll_x86);
        
        Log('delete bililive plugin -> "' + dst_dll_x64 + '"');
        DeleteFile(dst_dll_x64);
    end;
end;

// 将直播姬的OBS插件拷贝到OBS Studio的安装路径中
function CopyOrRemoveLivehimePluginsToOBSInstallPath(): Boolean;
var
    ObsInstallDir: String;
    src_dll_x86: String;
    src_dll_x64: String;
    dst_dll_x86: String;
    dst_dll_x64: String;
    mark_file_path : String;
begin
    Result := False;
    ObsInstallDir := GetOBSStudioInstallPath();
    if ObsInstallDir <> '' then begin
    
        // OBS插件注入与否的配置标识，由安装包生成或直播姬主程序生成
        mark_file_path := ExpandConstant('{localappdata}\Temp\Inject_OBS');
        
        src_dll_x86 := ExpandConstant('{app}\plugins\{#kBililiveOBSPluginName}');
        src_dll_x64 := ExpandConstant('{app}\x64\plugins\{#kBililiveOBSPluginName}');
        dst_dll_x86 := ExpandConstant(ObsInstallDir + '\obs-plugins\32bit\{#kBililiveOBSPluginName}');
        dst_dll_x64 := ExpandConstant(ObsInstallDir + '\obs-plugins\64bit\{#kBililiveOBSPluginName}');
        
        // 判断标识存在与否，存在才拷贝，不存在就删除
        if FileExists(mark_file_path) = true then begin
            Log('copy "' + src_dll_x86 + '" to "' + dst_dll_x86 + '"');
            FileCopy(src_dll_x86, dst_dll_x86, False);            
            
            Log('copy "' + src_dll_x64 + '" to "' + dst_dll_x64 + '"');
            FileCopy(src_dll_x64, dst_dll_x64, False);        
        end else begin
            EraseBililiveOBSPlugins();
        end;
        
        Result := True;
    end;
end;

// install finished //////////////////////////////////////////////////////////////////
procedure setupCompleteBtnClick(hBtn:HWND);
begin
   
    RunClickFlag(True);
    // 如果用户勾选了OBS插件注入，则生成配置标识，否则删掉
    CreateOrRemoveObsInjectFlag(BtnGetChecked(injectOBSPluginCheck));
    
    // 根据标识存在与否来决定是删插件还是安装/更新插件
    CopyOrRemoveLivehimePluginsToOBSInstallPath();

    // 安装结束后，在启动直播姬之前释放互斥
    CloseAppRejectMutex();
    WizardForm.NextButton.OnClick(WizardForm);
end;

procedure exitBtnClick(hBtn:HWND);
begin
    // Exit;
	RunClickFlag(False);
    ExitProcess(0);
end;

function DpToPx(Dp: Integer): Integer;
begin
    if g_is_high_dpi then begin
        Result := Trunc(Dp * g_dpi_scale);
    end else begin
        Result := Dp;
    end;
end;

procedure installFinished();
var
    old_bgImg : LongInt;
    inject_w : Integer;
    run_w : Integer;
    pendding : Integer;
    check_area_w : Integer;
    x : Integer;

begin
    old_bgImg := bgImg;

    bgImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\bg3' + g_dpi_suffix),
        0, 0, DpToPx(bgW), DpToPx(bgH),
        true, true);

    setupCompleteBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW - 177)/2), DpToPx(256), DpToPx(177), DpToPx(62),
        ExpandConstant('{tmp}\installCompleteBtn' + g_dpi_suffix),
        1, False)
    BtnSetEvent(setupCompleteBtn, BtnClickEventID, WrapBtnCallback(@setupCompleteBtnClick, 1));

    x := (bgW - 239)/2;
    injectOBSPluginCheck := BtnCreate(
        WizardForm.Handle,
        DpToPx(x), DpToPx(330), DpToPx(239), DpToPx(15),
        ExpandConstant('{tmp}\checkObsInject' + g_dpi_suffix), 1, true)
    BtnSetChecked(injectOBSPluginCheck, true);

  

    BtnSetEvent(cancelBtn, BtnClickEventID, WrapBtnCallback(@exitBtnClick, 1));

    ImgRelease(old_bgImg)
    ImgRelease(installingTVImg)
    ImgRelease(progressImg)
    ImgRelease(progressImgBg)

    RemoveOldUninstallEntry()
end;

// installing page //////////////////////////////////////////////////////////////////
procedure installingPage();
var
    old_bgImg : LongInt;

begin
    old_bgImg := bgImg;

    BtnSetVisibility(setupBtn,false)
    BtnSetVisibility(licenseCheck,false)
    BtnSetVisibility(licenseBtn,false)
    BtnSetVisibility(readLicenseBtn, false)
    BtnSetVisibility(browseBtn,false)
    BtnSetVisibility(licenseBackBtn,false)
    pathEdit.Hide();

    bgImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\bg1' + g_dpi_suffix),
        0, 0, DpToPx(bgW), DpToPx(bgH),
        True, True);
    installingTVImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingTV' + g_dpi_suffix),
        DpToPx((bgW-165)/2-25), DpToPx(84), DpToPx(211), DpToPx(186),
        True, True);

    installingTipImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingTip' + g_dpi_suffix),
        DpToPx((bgW - 570)/2), DpToPx(345), DpToPx(146), DpToPx(12),
        True, True);
    progressImgBg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingProcessBg' + g_dpi_suffix),
        DpToPx((bgW - 570)/2), DpToPx(360), DpToPx(570), DpToPx(6),
        True, True);
    progressImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingProcess' + g_dpi_suffix),
        DpToPx((bgW - 570)/2), DpToPx(360), 0, 0,
        True, True);

    // 在释放上一页的图片之前，先把当前页的图片加载出来，
    // 以免界面出现闪烁，下同
    ImgRelease(old_bgImg)
    ImgRelease(welcomeTVImg)
    ImgRelease(installDirImg)
    ImgRelease(pathEditImg)
end;

// welcome page //////////////////////////////////////////////////////////////////
procedure lockLicenseBtnClick(hBtn:HWND);
begin
    if licenseViewClose = true then begin
        BtnSetVisibility(setupBtn, false)
        BtnSetVisibility(licenseCheck, false)
        BtnSetVisibility(licenseBtn, false)
        BtnSetVisibility(readLicenseBtn, false)
        BtnSetVisibility(browseBtn, false)
        pathEdit.Hide;

        licenseImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\bg2' + g_dpi_suffix),
            0, 0, DpToPx(bgW), DpToPx(bgH),
            True, True);

        ImgRelease(bgImg)
        ImgRelease(welcomeTVImg)
        ImgRelease(installDirImg)
        ImgRelease(pathEditImg)

        ImgApplyChanges(WizardForm.Handle);

        licenseView.Height := DpToPx(licenseViewH);
        licenseView.SelStart := 0;
        licenseView.SelLength := 0;
        BtnSetVisibility(licenseBackBtn, true)
        licenseViewClose := false
    end else begin
        licenseView.Height := 0
        BtnSetVisibility(licenseBackBtn, false)
        licenseViewClose := true

        bgImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\bg1' + g_dpi_suffix),
            0, 0, DpToPx(bgW), DpToPx(bgH),
            True, True);
        welcomeTVImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\welcomeTV' + g_dpi_suffix),
            DpToPx((bgW-165)/2), DpToPx(84), DpToPx(165), DpToPx(141),
            True, True);
        pathEditImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\pathEditBg' + g_dpi_suffix),
            DpToPx(120), DpToPx(342), DpToPx(360), DpToPx(30),
            True, True);
        installDirImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\installDir' + g_dpi_suffix),
            DpToPx(45), DpToPx(350), DpToPx(66), DpToPx(15),
            True, True);

        BtnSetVisibility(setupBtn, true)
        BtnSetVisibility(licenseCheck, true)
        BtnSetVisibility(licenseBtn, true)
        BtnSetVisibility(readLicenseBtn, true)
        BtnSetVisibility(browseBtn, true)

        ImgRelease(licenseImg)
        ImgApplyChanges(WizardForm.Handle);
        
        // 等到页面上其他图片和控件加载完后，再显示这个编辑框，
        // 防止界面闪烁
        pathEdit.Show();
    end;
end;

procedure pathEditChange(Sender: TObject);
begin
    WizardForm.DirEdit.text:=pathEdit.Text;
end;

procedure browseBtnClick(hBtn:HWND);
begin
    WizardForm.DirBrowseButton.OnClick(WizardForm);
    pathEdit.text := WizardForm.DirEdit.text;
end;

procedure licenseCheckClick(hBtn:HWND);
begin
    if BtnGetChecked(licenseCheck)=true then
    begin
        BtnSetEnabled(setupBtn,true)
    end else begin
        BtnSetEnabled(setupBtn,false)
    end
end;

// Best efforts only...
function IsInstallLocationIllegal(program_dir_path: String): Boolean;
begin
    Result := ExtractFileDrive(program_dir_path) = '';
end;

function IsInstallLocationDriveRoot(program_dir_path: String): Boolean;
begin
    Result := program_dir_path = ExtractFileDir(program_dir_path);
end;

function IsInstallLocationPotentialRisk(program_dir: String): Boolean;
var
    program_dir_name: String;
    program_dir_path: String;
begin
    program_dir_path := program_dir;
    while program_dir_path <> ExtractFileDir(program_dir_path) do
    begin
        program_dir_name := ExtractFileName(program_dir_path);
        if (program_dir_name = 'bililive') or (program_dir_name = 'livehime') then begin
            Result := False;
            Exit;
        end;
        program_dir_path := ExtractFileDir(program_dir_path);
    end;
    Result := True;
end;

procedure setupBtnclick(hBtn:HWND);
var
    program_dir_path: String;
begin
    program_dir_path := RemoveBackslashUnlessRoot(pathEdit.Text);
    InstallClickFlag(True);
    if IsInstallLocationIllegal(program_dir_path) then begin
        MsgBox('安装路径不合法！', mbError, MB_OK);
        pathEdit.Text := ExpandConstant('{#SetupSetting("DefaultDirName")}');
        Exit;
    end;

    // Not allowed installing on drive root.
    if IsInstallLocationDriveRoot(program_dir_path) then begin
        MsgBox('直播姬不能被安装在根目录！', mbError, MB_OK);
        pathEdit.Text := ExpandConstant('{#SetupSetting("DefaultDirName")}');
        Exit;
    end;

    // Disclaimers.
    if IsInstallLocationPotentialRisk(program_dir_path) then begin
        if MsgBox('将直播姬安装在 bililive 或 livehime 之外的目录中可能和其他程序产生冲突' + #13#13 +
                  '是否继续安装?', mbConfirmation, MB_YESNO) <> IDYES then begin
            pathEdit.Text := ExpandConstant('{#SetupSetting("DefaultDirName")}');
            Exit;
        end;
    end;

    WizardForm.NextButton.OnClick(WizardForm);
end;

function NextButtonClick(CurPageID: Integer): Boolean;
var
    install_path: String;
begin
    if CurPageID = wpSelectDir then begin
        if not g_update_mode then begin
            install_path := WizardForm.DirEdit.text;
            install_path := AddBackSlash(AddBackSlash(install_path) + '{#kAppVersion}');
            WizardForm.DirEdit.text := install_path;
        end;
    end;

    Result := True;
end;

procedure welcomePage();
begin
    if g_installed_app_version <> '' then begin
	   g_installed_boolean := True;
	end;
    bgImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\bg1' + g_dpi_suffix),
        0, 0, DpToPx(bgW), DpToPx(bgH),
        True, True);
    welcomeTVImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\welcomeTV' + g_dpi_suffix),
        DpToPx((bgW-165)/2), DpToPx(84), DpToPx(165), DpToPx(141),
        True, True);

    setupBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW - 223)/2), DpToPx(216), DpToPx(223), DpToPx(69),
        ExpandConstant('{tmp}\setupBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(setupBtn,BtnClickEventID,WrapBtnCallback(@setupBtnclick,1));

    licenseCheck := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW-119-92)/2), DpToPx(290), DpToPx(119), DpToPx(15),
        ExpandConstant('{tmp}\checkLicense' + g_dpi_suffix), 1, true)
    BtnSetEvent(licenseCheck,BtnClickEventID,WrapBtnCallback(@licenseCheckClick,1));
    BtnSetChecked(licenseCheck,true)

    readLicenseBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW-211)/2 + 119), DpToPx(291), DpToPx(92), DpToPx(14),
        ExpandConstant('{tmp}\readLicenseBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(readLicenseBtn,BtnClickEventID,WrapBtnCallback(@lockLicenseBtnClick,1));

    licenseBackBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW - 80) / 2), DpToPx(350), DpToPx(80), DpToPx(30),
        ExpandConstant('{tmp}\licenseBackBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(licenseBackBtn,BtnClickEventID,WrapBtnCallback(@lockLicenseBtnClick,1));
    BtnSetVisibility(licenseBackBtn,false)

    licenseView := TRichEditViewer.Create(WizardForm);
    with licenseView do
        begin
            Parent := WizardForm;
            ReadOnly:= true;
            SCROLLBARS:= ssVertical;
            Font.Name:='微软雅黑'
            Font.Size := 9;
            Color:=clWhite;
            BorderStyle:= bsNone;
            SetBounds(DpToPx((bgW - licenseViewW) / 2), DpToPx(50), DpToPx(licenseViewW), DpToPx(licenseViewH))
            Lines.LoadFromFile(ExpandConstant('{tmp}\license.txt'));
            TabStop:=false;
            Height := 0;
        end;


    installDirImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installDir' + g_dpi_suffix),
        DpToPx(45), DpToPx(350), DpToPx(66), DpToPx(15),
        True, true);
    pathEditImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\pathEditBg' + g_dpi_suffix),
        DpToPx(120), DpToPx(342), DpToPx(360), DpToPx(30),
        True, true);
    pathEdit := TEdit.Create(WizardForm);
    with pathEdit do
        begin
            Parent := WizardForm;
            text :=WizardForm.DirEdit.text;
            Font.Name:='微软雅黑'
            Font.Size := 10;
            BorderStyle:=bsNone;
            SetBounds(DpToPx(126), DpToPx(348), DpToPx(348), DpToPx(18))
            OnChange:=@pathEditChange;
            Color := $00FFFFFF;
            TabStop :=false;
        end;

    browseBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx(480), DpToPx(342), DpToPx(80), DpToPx(30),
        ExpandConstant('{tmp}\browseBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(browseBtn,BtnClickEventID,WrapBtnCallback(@browseBtnClick,1));
end;

procedure CurPageChanged(CurPageID: Integer);
var
    param: Longint;
begin
    // Don't simply make the next button invisible, we need to simulate click event on next button
    // to proceed installation automatically.
    WizardForm.NextButton.Height := 0;
    WizardForm.CancelButton.Height := 0;
    WizardForm.BackButton.Height:=0;

    if CurPageID = wpWelcome then begin
        welcomePage();
    end;

    if CurPageID = wpReady then begin
        param := 0 or BN_CLICKED shl 16;
        PostMessage(WizardForm.NextButton.Handle, CN_COMMAND, param, 0);
    end;

    if CurPageID = wpInstalling then begin
        installingPage();
    end;

    if CurPageID = wpFinished then begin
        //installFinished();
	   RunClickFlag(True);
      // 如果用户勾选了OBS插件注入，则生成配置标识，否则删掉
      CreateOrRemoveObsInjectFlag(true);
    
      // 根据标识存在与否来决定是删插件还是安装/更新插件
      CopyOrRemoveLivehimePluginsToOBSInstallPath();

      // 安装结束后，在启动直播姬之前释放互斥
      CloseAppRejectMutex();
      WizardForm.NextButton.OnClick(WizardForm);
    end;

    ImgApplyChanges(WizardForm.Handle)
end;

function ShouldSkipPage(PageID: Integer): Boolean;
begin
    Result := True;

    // Display installing page only in update mode.
    if g_update_mode then begin
        if (PageID = wpInstalling) then begin
            Result := False;
        end;

        if PageID = wpFinished then begin
            // 判断一下，如果没有特定标识，则把obs插件目录中已经注入的dll给删掉，
            // 如果标识存在则将OBS插件复制过去，更新一波
            CopyOrRemoveLivehimePluginsToOBSInstallPath();
            
            CloseAppRejectMutex();
			RemoveOldUninstallEntry();
        end;
        Exit;
    end;

    if (PageID = wpWelcome) or
       (PageID = wpInstalling) or
	   (PageID = wpSelectDir) or
       (PageID = wpFinished) then
        Result := false;
end;

procedure ShapeForm(aForm: TForm; edgeSize: integer); // 圆角
var
    FormRegion:LongWord;
begin
    FormRegion:=CreateRoundRectRgn(0, 0, aForm.Width, aForm.Height, edgeSize, edgeSize);
    SetWindowRgn(aForm.Handle, FormRegion, True);
end;

function PBProc(handle:hWnd; Msg, wParam, lParam:Longint):Longint;
var
    pr, i1, i2 : Extended;
    w : Integer;
    h : Integer;
begin
    Result := CallWindowProc(progressProc, handle, Msg, wParam, lParam);
    if (Msg = $402) and (WizardForm.ProgressGauge.Position > WizardForm.ProgressGauge.Min) then begin
        i1 := WizardForm.ProgressGauge.Position - WizardForm.ProgressGauge.Min;
        i2 := WizardForm.ProgressGauge.Max - WizardForm.ProgressGauge.Min;
        pr := i1 / i2;
        w := Round(570 * pr);
        ImgSetPosition(progressImg, DpToPx((bgW - 570)/2), DpToPx(360), DpToPx(w), DpToPx(6));

        h := 6;
        if g_is_high_dpi then begin
            w := w * 2;
            h := 12;
        end;

        ImgSetVisiblePart(progressImg, 0, 0, w, h);
        ImgApplyChanges(WizardForm.Handle);
    end;
end;

procedure initWizardForm();
var
    MainLabel: TLabel;
begin
    WizardForm.OuterNotebook.Hide();
    WizardForm.Bevel.Hide();
    WizardForm.BorderStyle := bsnone;
    WizardForm.Position := poScreenCenter;
    WizardForm.Width := DpToPx(bgW) + 1;
    WizardForm.Height := DpToPx(bgH) + 1;
    WizardForm.Color := clWhite;
    ShapeForm(WizardForm, Radius);

    // 只是用来处理拖动的透明控件
    MainLabel := TLabel.Create(WizardForm);
    MainLabel.Parent := WizardForm;
    MainLabel.AutoSize := False;
    MainLabel.Left := 0;
    MainLabel.Top := 0;
    MainLabel.Width := WizardForm.Width;
    MainLabel.Height := WizardForm.Height;
    MainLabel.Caption := '';
    MainLabel.Transparent := True;
    MainLabel.OnMouseDown := @WizardMouseDown;

    cancelBtn := BtnCreate(
        WizardForm.Handle,
        (DpToPx(bgW) - DpToPx(32)), DpToPx(2), DpToPx(30), DpToPx(30),
        ExpandConstant('{tmp}\closeBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(cancelBtn,BtnClickEventID,WrapBtnCallback(@cancelBtnClick,1));
    minBtn := BtnCreate(
        WizardForm.Handle,
        (DpToPx(bgW) - DpToPx(62)), DpToPx(2), DpToPx(30), DpToPx(30),
        ExpandConstant('{tmp}\minBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(minBtn,BtnClickEventID,WrapBtnCallback(@minBtnClick,1));

    licenseViewClose := true;
    progressProc:=SetWindowLong(WizardForm.ProgressGauge.Handle, -4, PBCallBack(@PBProc, 4));
end;

function ValidateWin7OrLater(): Boolean;
var
    os_ver: TWindowsVersion;
begin
    Result := True;
    GetWindowsVersionEx(os_ver);
    if (os_ver.Major < 6) or
       ((os_ver.Major = 6) and (os_ver.Minor = 0)) then begin
        SuppressibleMsgBox('{#kAppName}需要运行在windows 7及以上的操作系统', mbCriticalError, MB_OK, IDOK);
        Result := False;
    end;
end;

function GetNumber(var temp: String): Integer;
var
    part: String;
    pos1: Integer;
begin
    if Length(temp) = 0 then begin
        Result := -1;
        Exit;
    end;

    pos1 := Pos('.', temp);

    if (pos1 = 0) then begin
        Result := StrToIntDef(temp, 0);
        temp := '';
    end else begin
        part := Copy(temp, 1, pos1 - 1);
        temp := Copy(temp, pos1 + 1, Length(temp));
        Result := StrToIntDef(part, 0);
    end;
end;

function CompareInner(var temp1, temp2: String): Integer;
var
    num1, num2: Integer;
begin
    num1 := GetNumber(temp1);
    num2 := GetNumber(temp2);
    if (num1 = -1) or (num2 = -1) then begin
        Result := 0;
        Exit;
    end;

    if (num1 > num2) then begin
        Result := 1;
    end else if (num1 < num2) then begin
        Result := -1;
    end else begin
        Result := CompareInner(temp1, temp2);
    end;
end;

// positive, if str1 > str2
// 0, if str1 == str2
// negative, if str1 < str2
function CompareVersion(str1, str2: String): Integer;
var
    temp1, temp2: String;
begin
    // 对str进行一下正则判断最好
    temp1 := str1;
    temp2 := str2;
    Result := CompareInner(temp1, temp2);
end;

function StartsWith(SubStr, S: String):Boolean;
begin
    Result:= Pos(SubStr, S) = 1;
end;

function StringReplace(S, oldSubString, newSubString: String) : String;
var
    stringCopy : String;
begin
    stringCopy := S;
    StringChange(stringCopy, oldSubString, newSubString);
    Result := stringCopy;
end;

function GetCommandlineParam(inParamName: String):String;
var
    paramNameAndValue: String;
    i: Integer;
begin
    Result := '';
    for i:= 0 to ParamCount do
    begin
        paramNameAndValue := ParamStr(i);
        if (StartsWith(inParamName, paramNameAndValue)) then begin
            Result := StringReplace(paramNameAndValue, inParamName + '=', '');
            break;
        end;
    end;
end;

function HasCommandlineSwitch(switch_name: String): Boolean;
var
    i: Integer;
    paramNameAndValue: String;
begin
    for i:= 0 to ParamCount do
    begin
        paramNameAndValue := ParamStr(i);
        if (StartsWith(switch_name, paramNameAndValue)) then begin
            Result := True;
            break;
        end;
    end;
end;

// This is the first step invoked by our installer.
// Returns False to abort the installation.
function InitializeSetup: Boolean;
var
    installed_app_version: String;
    install_location: String;
    retry_count: Integer;
begin
    // 检查是否已经存在安装程序
    if CheckForMutexes(kSetupSelfMutex) then begin
        Result := False;
        Exit;
    end;
    
    CreateMutex(kSetupSelfMutex);
    // 这个互斥需要在安装程序退出之前释放，所以不能用内建的互斥函数
    g_app_reject_mutex := CreateMutexRaw(0, False, kSetupRejectAppMutex);

    // For being accurate, we should call WaitForSingleObject() on livehime's process handle;
    // However, it might be overkill in real world, much less potential risks it involes.
    if HasCommandlineSwitch('--hot-update') then begin
        // Wait livehime process to exit.
        While (CheckForMutexes(kInstanceRunningMutex)) and (retry_count < 5) do begin
            Sleep(1500);
            retry_count := retry_count + 1;
        end;
    end;

    // We only allow livehime running on Windows 7 or later.
    if not ValidateWin7OrLater() then begin
        Exit;
    end;

    // We here use the same mutex used by bililive itself to prevent running multiple instances.
    while CheckForMutexes(kInstanceRunningMutex) do begin
        if Msgbox('安装程序检测到{#kAppName}正在运行.' #13#13 '您必须先关闭它然后单击 "是" 继续安装, 或按 "否" 退出!',
                  mbConfirmation, MB_YESNO) = idNO then begin
            Exit;
        end
    end;
    
    g_installed_app_version := '';

    if GetUninstallRegEntry('DisplayVersion', installed_app_version) then begin
		g_installed_app_version := installed_app_version;
        if CompareVersion(installed_app_version, '1.0.1.638') < 0 then begin
            MsgBox('检测到无法兼容的史前版本 {#kAppName} v' + installed_app_version + #13#13 +
                   '请先手动卸载史前版本，再重试安装', mbCriticalError, MB_OK);
            Exit;
        end;

        if CompareVersion(installed_app_version, '{#kAppVersion}') > 0 then begin
            if not HasCommandlineSwitch('--force-install') then begin
                MsgBox('您已经安装更高版本的 {#kAppName} v' + installed_app_version, mbCriticalError, MB_OK);
                Exit;
            end;
        end;

        // If the install location is not empty yet inaccessible, we fallback to normal mode.
        if GetUninstallRegEntry('InstallLocation', install_location) then begin
            install_location := ExtractFileDir(RemoveBackslashUnlessRoot(install_location));
            if (Length(install_location) <> 0) and (DirExists(install_location))  then begin
                g_update_mode := True;
                g_old_version_install_dir := install_location;
            end;
        end;
    end;

    Result := True;
end;

procedure DeinitializeSetup();
begin
    CloseAppRejectMutex();
    gdipShutdown();
end;

procedure ExtractImgWithSuffix(dpi_suffix: String);
begin
    ExtractTemporaryFile('bg1' + dpi_suffix);
    ExtractTemporaryFile('bg2' + dpi_suffix);
    ExtractTemporaryFile('bg3' + dpi_suffix);
    ExtractTemporaryFile('closeBtn' + dpi_suffix);
    ExtractTemporaryFile('minBtn' + dpi_suffix);
    ExtractTemporaryFile('setupBtn' + dpi_suffix);
    ExtractTemporaryFile('checkRun' + dpi_suffix);
    ExtractTemporaryFile('checkObsInject' + dpi_suffix);
    ExtractTemporaryFile('checkLicense' + dpi_suffix);
    ExtractTemporaryFile('installingTV' + dpi_suffix);
    ExtractTemporaryFile('installCompleteBtn' + dpi_suffix);
    ExtractTemporaryFile('installingProcess' + dpi_suffix);
    ExtractTemporaryFile('installingProcessBg' + dpi_suffix);
    ExtractTemporaryFile('welcomeTV' + dpi_suffix);
    ExtractTemporaryFile('readLicenseBtn' + dpi_suffix);
    ExtractTemporaryFile('licenseBackBtn' + dpi_suffix);
    ExtractTemporaryFile('pathEditBg' + dpi_suffix);
    ExtractTemporaryFile('installDir' + dpi_suffix);
    ExtractTemporaryFile('browseBtn' + dpi_suffix);
    ExtractTemporaryFile('license.txt');
    ExtractTemporaryFile('installingTip' + dpi_suffix);
end;


procedure CheckDPI();
var
    current_dpi, standard_dpi: Integer;
begin
    current_dpi := WizardForm.Font.PixelsPerInch;
    standard_dpi := 96;
    if (current_dpi > standard_dpi) then begin
        g_dpi_suffix := '_2x.png';
        g_dpi_scale := current_dpi * 1.0 / standard_dpi;
        g_is_high_dpi := True;
    end else begin
        g_dpi_suffix := '.png';
        g_dpi_scale := 1;
        g_is_high_dpi := False;
    end;
end;

procedure InitializeWizard();
var
    install_path: String;
begin
    CheckDPI();
    ExtractImgWithSuffix(g_dpi_suffix);
    initWizardForm();
    if g_update_mode then begin
        install_path := AddBackslash(AddBackslash(g_old_version_install_dir) + '{#kAppVersion}');
        WizardForm.DirEdit.text := install_path;
    end;
end;

procedure TerminateProcess(ProcName: String);
var
    WbemLocator: Variant;
    WMIService: Variant;
    WbemObjectSet: Variant;
    WbemObject: Variant;
    i: Integer;
begin;
    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := WbemLocator.ConnectServer('localhost', 'root\CIMV2');
    WbemObjectSet := WMIService.ExecQuery('SELECT * FROM Win32_Process Where Name="' + ProcName + '"');
    if not VarIsNull(WbemObjectSet) and (WbemObjectSet.Count > 0) then begin
        for i := 0 to WbemObjectSet.Count - 1 do
        begin
            WbemObject := WbemObjectSet.ItemIndex(i);
            if not VarIsNull(WbemObject) then begin
                WbemObject.Terminate();
            end;
        end;
    end;
end;

procedure CopyLauncherExe();
var
    src_exe_path: String;
    tmp_exe_path: String;
    dest_exe_path: String;
begin
    src_exe_path := ExpandConstant('{app}\livehime.exe');
    tmp_exe_path := ExpandConstant('{app}\..\new_livehime.exe');
    dest_exe_path := ExpandConstant('{app}\..\livehime.exe');

    FileCopy(src_exe_path, tmp_exe_path, False);
    DelayDeleteFile(dest_exe_path, 3);

    if not RenameFile(tmp_exe_path, dest_exe_path) then begin
        Log('Failed to swap the launcher exe, trying to terminate process now...');
        // Take terminating processes as the last resort.
        TerminateProcess('livehime.exe');
        DelayDeleteFile(dest_exe_path, 5);
        RenameFile(tmp_exe_path, dest_exe_path);
    end;
end;

// Hard coded for version format like 1.1.0.123
function GuessVersionDir(dir_name: String): Boolean;
var
    test_count: Integer;
    i: Integer;
    cut_len: Integer;
    tmp: String;
    ver_cp: String;
begin
    test_count := 0;
    tmp := dir_name;
    while tmp <> '' do
    begin
        i := Pos('.', tmp);
        cut_len := i - 1;
        if i = 0 then begin
            cut_len := Length(tmp);
        end;
        ver_cp := Copy(tmp, 1, cut_len);
        if StrToIntDef(ver_cp, -1) < 0 then begin
            Exit;
        end;
        if i = 0 then begin
            tmp := '';
        end else begin
            tmp := Copy(tmp, i + 1, Length(tmp) - i);
            test_count := test_count + 1;
        end;
    end;
    Result := test_count = 3;
end;

procedure RemoveObsoleteProgramDirs();
var
    program_dir_pattern: String;
    file_find_rec: TFindRec;
    target_dirs: array of String;
    num_found: Integer;
    i: Integer;
    dir_name_to_purge: String;
    dir_name_for_purge: String;
begin
    program_dir_pattern := ExpandConstant('{app}\..\*');
    if FindFirst(program_dir_pattern, file_find_rec) then begin
        // yeah, hard-coded, bite me?!
        SetArrayLength(target_dirs, 100);
        try
            repeat
                if ((file_find_rec.Attributes and FILE_ATTRIBUTE_DIRECTORY) <> 0) and
                   (file_find_rec.Name <> '.') and
                   (file_find_rec.Name <> '..') and
                   (file_find_rec.Name <> '{#kAppVersion}') then begin
                    if GuessVersionDir(file_find_rec.Name) then begin
                        Log('Tracked ' + file_find_rec.Name);
                        target_dirs[num_found] := file_find_rec.Name;
                        num_found := num_found + 1;
                    end;
                end;
            until not FindNext(file_find_rec);
        finally
            FindClose(file_find_rec);
        end;

        // Let's take them down.
        if num_found > 0 then begin
            for i := 0 to num_found - 1 do
            begin
                dir_name_to_purge := ExpandConstant('{app}\..\') + target_dirs[i];
                dir_name_for_purge := ExpandConstant('{app}\..\') + target_dirs[i] + '_';
                if not RenameFile(dir_name_to_purge, dir_name_for_purge) then begin
                    Log('Can''t rename ' + dir_name_to_purge);
                    continue;
                end;
                DelTree(dir_name_for_purge, True, True, True);
            end;
        end;
    end;
end;

// The program can distinguish update from brand new installation, and do something necessary
// when update being the case.
procedure MarkLivehimeUpdted();
var
    mark_file_path: String;
begin
    mark_file_path := ExpandConstant('{localappdata}\bililive\User Data\Update\Updated Run');
    if HasCommandlineSwitch('--hot-update') then begin
        SaveStringToFile(mark_file_path, '1', False);
    end else begin
        SaveStringToFile(mark_file_path, '', False);
    end;
end;

procedure CurStepChanged(CurStep: TSetupStep);
begin
    // After installation succeeds, we need to setup the top-level launcher exe.
    if CurStep = ssPostInstall then begin
        CopyLauncherExe();
        if g_update_mode then begin
            MarkLivehimeUpdted();
        end;
    end;

    if CurStep = ssDone then begin
        if g_update_mode and not HasCommandlineSwitch('--keep-old') then begin
            RemoveObsoleteProgramDirs();
        end;
    end;
end;

// -*- Uninstall -*-

// First funciton invoked during uninstallation.
function InitializeUninstall(): Boolean;
begin
    if CheckForMutexes(kSetupSelfMutex) then begin
        Msgbox('请先等待{#kAppName}的当前安装/卸载完成.', mbConfirmation, MB_OK);
        Result := False;
        Exit;
    end;
    
    CreateMutex(kSetupSelfMutex);
    CreateMutex(kSetupRejectAppMutex);

    while CheckForMutexes(kInstanceRunningMutex) do begin
        if Msgbox('卸载程序检测到{#kAppName}正在运行.' #13#13 '您必须先关闭它然后单击 "是" 继续卸载, 或按 "否" 退出!',
                  mbConfirmation, MB_YESNO) = idNO then begin
            Result := False;
            Exit;
        end
    end;

    Result := True;
end;

procedure EraseUserDataFiles();
var
    user_data_dir_path: String;
begin
    user_data_dir_path := ExpandConstant('{localappdata}\bililive');
    if DirExists(user_data_dir_path) then begin
        if MsgBox('同时删除配置文件吗?'  #13#13 '   ' + user_data_dir_path, mbConfirmation, MB_YESNO) = IDYES then begin
            // I really don't know under what circumstances we may fail to delete user data files;
            // But if this was the case, just let it go, there is nothing else we can do.
            DelTree(user_data_dir_path, True, True, True);
        end;
    end;
end;

// Pre-assume users won't store any private data/files in our program directory; or they didn't do
// any stupid during installation.
// Install location is the path our uninstall registry entry indicates, usually being a folder named
// after livehime version.
// program directory is the one that contains launcher exe.
procedure EraseProgramDir();
var
    install_location: String;
    program_dir_path: String;
begin
    install_location := RemoveBackslashUnlessRoot(ExpandConstant('{app}'));
    program_dir_path := ExtractFileDir(install_location);

    // Oops, for the sake of the god, be cautious.
    if IsInstallLocationPotentialRisk(program_dir_path) then begin
        if MsgBox('检测到直播姬并未安装在livehime或bililive文件夹，为了避免误删文件' #13#13 +
                  '确定要删除目录 ' + program_dir_path + ' 下的所有程序数据吗?', mbConfirmation, MB_YESNO) <> IDYES then begin
            Exit;
        end;
    end;

    if DirExists(program_dir_path) then begin
        DelTree(program_dir_path, True, True, True);
    end;
end;

procedure EraseTempDataFiles();
var
    tmp_data_dir: String;
begin
    tmp_data_dir := GetTempDir() + 'BililiveUD';
    if DirExists(tmp_data_dir) then begin
        DelTree(tmp_data_dir, True, True, True);
    end;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
    program_dir_path: String;
begin
    if CurUninstallStep = usPostUninstall then begin
        EraseProgramDir();
        EraseUserDataFiles();
        EraseTempDataFiles();
        EraseBililiveOBSPlugins();
    end;
end;

//Check VCRT
// 32/64位系统检查32/64位程序，64位系统的32位安装包程序检查1、2会自动映射检查到3、4
function CheckVCRTByReg1(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Microsoft\DevDiv\vc\Servicing\14.0\RuntimeMinimum';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Install', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x64 DevDiv -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

function CheckVCRTByReg2(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x86';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Installed', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        // 去掉VS版本前面可能带的‘v’字符，这个地方引入正则进行判断最好
        if Lowercase(Copy(Version, 1, 1)) = 'v' then begin
            Version := Copy(Version, 2, Length(Version));
        end;
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x64 VisualStudio -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

// 检查64位系统的32位注册表
function CheckVCRTByReg3(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Wow6432Node\Microsoft\DevDiv\vc\Servicing\14.0\RuntimeMinimum';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Install', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x86 DevDiv -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

function CheckVCRTByReg4(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\VC\Runtimes\x86';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Installed', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        // 去掉VS版本前面可能带的‘v’字符，这个地方引入正则进行判断最好
        if Lowercase(Copy(Version, 1, 1)) = 'v' then begin
            Version := Copy(Version, 2, Length(Version));
        end;
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x86 VisualStudio -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

//function CheckVCRTByReg5(): Boolean;
//var
//    Key: String;
//    dwInstalled: Cardinal;
//begin
//    Key := 'SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\VC\Runtimes\x64';
//    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Installed', dwInstalled) then begin
//        if dwInstalled = 1 then
//            Result := True
//        else
//            Result := False
//    end else
//        Result := False
//end;

function CheckVCRT(): Boolean;
begin
    // 以前从1检查到5，即包括x64的检查，但是安装包中并未包含x64的redist，现在改为不检查x64，当前项目中只有三个exe项目编了x64的，
    // 使用静态链接即可，以后发现有问题了再包含x64的redist，一个redist十几兆，有点大了，没问题就暂时不加
    if CheckVCRTByReg1() and CheckVCRTByReg2() and CheckVCRTByReg3() and CheckVCRTByReg4() then begin
        //MsgBox('vc_redist found', mbConfirmation, MB_OK);
        Result := False;
    end else begin
        //MsgBox('vc_redist not found', mbConfirmation, MB_OK);
        Result := True;
    end
end;

function GetCustomSetupExitCode: Integer;
begin
    Result := 0;
    ExitProcess(0);
end;
