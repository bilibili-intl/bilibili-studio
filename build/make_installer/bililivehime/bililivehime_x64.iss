; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
#define kInputDir           GetEnv('INNO_INPUT_DIR')
#define kLicenseFile        GetEnv('INNO_LICENSE_FILE')
#define kOutputDir          GetEnv('INNO_OUTPUT_DIR')
#define kOutputFileName     GetEnv('INNO_OUTPUT_FILENAME')
#define kInstallerIconFile  GetEnv('INNO_OUTPUT_FILEICON')
#define kSetupResDir        GetEnv('INNO_SETUP_RES_DIR')
#define kAppVersion         GetEnv('INNO_APP_VERSION')

; #define kInputDir           "D:\\work\\code\\bililive-win\\build\\make_installer\\program_raw"
; #define kLicenseFile        "D:\work\\code\\bililive-win\\build\\make_installer\\bililivehime\\res\\license.txt"
; #define kOutputDir          "D:\work\\code\\bililive-win\\build\\make_installer\\bililivehime"
; #define kOutputFileName     "livehimeintl-release-x64-4.20.0.3400"
; #define kInstallerIconFile  "D:\work\\code\\bililive-win\\build\\make_installer\\bililivehime\\res\\inst_icon.ico"
; #define kSetupResDir        "D:\work\\code\\bililive-win\\build\\make_installer\\bililivehime\\res"
; #define kAppVersion         "4.20.0.3400"

#define kAppId           "{A6BAC17A-7C9A-4C8F-9A1E-C2279CC092F4}"
#define kAppX86Id        "{436F46D3-85A3-426F-9E48-89A53F47D704}"
#define kAppName         "Bilibili Studio (Beta)"
#define kAppPublisher    "BALABOOM PTE.LTD."
#define kAppURL          "https://www.bilibili.tv/"
#define kAppExeName      "Bilibili Studio.exe"
#define kFWRuleName      "Bililive Screencast"

#define kBililiveOBSPluginName      "bililive_obs_plugin.dll"

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{#kAppId}
AppName={#kAppName}
AppVersion={#kAppVersion}
AppPublisher={#kAppPublisher}
AppPublisherURL={#kAppURL}
AppSupportURL={#kAppURL}
AppUpdatesURL={#kAppURL}
DefaultDirName={commonpf}\bililive\Bilibili Studio
DisableDirPage=no
DisableProgramGroupPage=yes
;LicenseFile={#kLicenseFile}
ArchitecturesAllowed=x64
ArchitecturesInstallIn64BitMode=x64
OutputDir={#kOutputDir}
OutputBaseFilename={#kOutputFileName}
Compression=lzma2
SolidCompression=yes
AppMutex="F43A293C-7CD8-478E-A390-217B0AE9AF89"
VersionInfoCompany={#kAppPublisher}
VersionInfoCopyright="Copyright (C) 2023 Bilibili. All Right Reserved."
VersionInfoDescription="{#kAppName} Setup"
VersionInfoVersion={#kAppVersion}
VersionInfoTextVersion={#kAppVersion}
SetupIconFile={#kInstallerIconFile}
SetupLogging=yes
UsePreviousAppDir=no
UninstallDisplayIcon={app}\{#kAppExeName}
UninstallDisplayName={#kAppName}
; ShowLanguageDialog=yes

[Languages]
Name: "en_US"; MessagesFile: "compiler:Default.isl";
Name: "zh_CN"; MessagesFile: "compiler:Languages\ChineseSimplified.isl";
Name: "id_ID"; MessagesFile: "compiler:Languages\Indonesian.isl";
Name: "th_TH"; MessagesFile: "compiler:Languages\Thai.isl";

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: exclusive
Name: "quicklaunchicon"; Description: "{cm:CreateQuickLaunchIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked; OnlyBelowVersion: 0,6.1

[Registry]
Root: HKCR; Subkey: "Bilibili Studio"; ValueType: string; ValueName: "URL Protocol"; ValueData: ""; Flags: uninsdeletekey
Root: HKCR; Subkey: "Bilibili Studio\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: """{app}\{#kAppExeName},1"""; Flags: uninsdeletekey
Root: HKCR; Subkey: "Bilibili Studio\Shell\Open\command"; ValueType: string; ValueName: ""; ValueData: """{app}\{#kAppExeName}"" --livehime-type=scheme --scheme=""%1"""; Flags: uninsdeletekey

[code]
var
  g_installed_app_version: String;
	g_installed_boolean: Boolean;

function IsWindows7(): Boolean;
var
    os_ver: TWindowsVersion;
begin
    Result := False;
    GetWindowsVersionEx(os_ver);
    if (os_ver.Major = 6) and (os_ver.Minor = 1) then begin
        Result := True;
    end;
end;

function ShouldCopyFile(): Boolean;
var
    filename: String;
begin
    Result := True;
    // 封包的源数据中，不要有空的目录，否则启动时CurrentFileName()会报错，这应该是inno setup的bug
    // An attempt was made to call the "CurrentFilename" function from outside a "Check", "CurrentFileName" or "AfterInstall" event function belonging to a "[Files]" entry.'
    filename := ExtractFileName(CurrentFileName());
    if (filename = 'D3DCompiler_43.dll') and not IsWindows7() then begin
        Result := False;
        Log('Skip copying ' + filename);
    end;
end;

// 立即安装注入配置标识
procedure InstallClickFlag(bIs:Boolean);
var
    mark_file_path : String;
begin
    // 立即安装注入配置标识
    mark_file_path := ExpandConstant('{localappdata}\Temp\');
	//如果没有安装过，才注入配置标识
    if not g_installed_boolean then begin
	  if bIs = true then begin
        SaveStringToFile(mark_file_path + 'livehime_install_click', '1', False);
      end else begin
        SaveStringToFile(mark_file_path + 'livehime_install_click', '0', False);
      end;
	end;
    
end;

// 立即体验注入配置标识
procedure RunClickFlag(bIs:Boolean);
var
    mark_file_path : String;
begin
    //如果没有安装过，才注入配置标识
    mark_file_path := ExpandConstant('{localappdata}\Temp\');
    if not g_installed_boolean then begin
	  if bIs = true then begin
         SaveStringToFile(mark_file_path + 'livehime_run_click', '1', False);
      end else begin
         SaveStringToFile(mark_file_path + 'livehime_run_click', '0', False);
      end;
	end;
end;


// 获取应用路径的父路径，即不带版本号的路径
function GetAppParentFolder(Param: String) : String;
begin
    Result := ExtractFilePath(ExpandConstant('{app}'));
end;

// 当前已安装的直播姬版本号（读注册表）。如果当前未安装，则返回空字符串
function GetInstalledAppVersion(Param: String) : String;
begin
    Result := g_installed_app_version;
end;

[Files]
Source: "{#kInputDir}\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs; Check: ShouldCopyFile()
Source: "{#kSetupResDir}\InnoCallBack.dll"; DestDir: {tmp}; Flags: dontcopy
Source: "{#kSetupResDir}\botva2.dll"; DestDir: {tmp}; Flags: dontcopy
Source: res\*; DestDir: {tmp}; Flags: dontcopy solidbreak ; Attribs: hidden system;
Source: res\en_US\*; DestDir: {tmp}; Flags: dontcopy solidbreak ; Attribs: hidden system; Languages: en_US
Source: res\zh_CN\*; DestDir: {tmp}; Flags: dontcopy solidbreak ; Attribs: hidden system; Languages: zh_CN
Source: res\id_ID\*; DestDir: {tmp}; Flags: dontcopy solidbreak ; Attribs: hidden system; Languages: id_ID
Source: res\th_TH\*; DestDir: {tmp}; Flags: dontcopy solidbreak ; Attribs: hidden system; Languages: th_TH

[Icons]
Name: "{commonprograms}\{#kAppName}\{#kAppName}"; Filename: "{app}\..\{#kAppExeName}"; IconFilename: "{app}\{#kAppExeName}"
Name: "{commonprograms}\{#kAppName}\{code:GetUninstallProgram}"; Filename: "{app}\unins000.exe"
Name: "{commondesktop}\{#kAppName}"; Filename: "{app}\..\{#kAppExeName}"; IconFilename: "{app}\{#kAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#kAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(kAppName, '&', '&&')}}"; Flags: nowait shellexec postinstall skipifsilent; Parameters:"--language={code:GetLanguage}"
Filename: "{app}\vc_redist.x86.exe"; Parameters: "/c /install /quiet /norestart /log  {tmp}\livehime_vc_redist_86.log"; Check:  CheckVCRTByReg4; StatusMsg: "Installing Microsoft Visual C++ 2015~2019 Redistributable Package (x86)"; Flags: nowait runascurrentuser
Filename: "{app}\vc_redist.x64.exe"; Parameters: "/c /install /quiet /norestart /log  {tmp}\livehime_vc_redist_x64.log"; Check: CheckVCRTByReg5; StatusMsg: "Installing Microsoft Visual C++ 2015~2019 Redistributable Package (x64)"; Flags: nowait runascurrentuser
// 先把原来添加的防火墙规则删掉
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{code:GetInstalledAppVersion}\{#kAppExeName}"" protocol=tcp"; Flags: waituntilterminated runhidden skipifdoesntexist
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{#kAppExeName}"" protocol=tcp"; Flags: waituntilterminated runhidden skipifdoesntexist
// 添加防火墙规则
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall add rule name=""{#kFWRuleName}"" dir=in program=""{app}\{#kAppExeName}"" protocol=tcp action=allow"; Flags: nowait runhidden skipifdoesntexist
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall add rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{#kAppExeName}"" protocol=tcp action=allow"; Flags: nowait runhidden skipifdoesntexist

[UninstallRun]
// 删除防火墙规则
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{app}\{#kAppExeName}"" protocol=tcp"; Flags: nowait runhidden skipifdoesntexist
Filename: "{sys}\netsh.exe"; Parameters: "advfirewall firewall delete rule name=""{#kFWRuleName}"" dir=in program=""{code:GetAppParentFolder}\{#kAppExeName}"" protocol=tcp"; Flags: nowait runhidden skipifdoesntexist

[Code]
type
  TBtnEventProc = procedure(h:HWND);
  TPBProc = function(h:hWnd; Msg, wParam, lParam:Longint):Longint;
  TTimerProc = procedure(h:longword; msg:longword; idevent:longword; dwTime:longword);

// innocallback.dll //////////////////////////////////////////////////////////////////
function  WrapTimerProc(callback: TTimerProc; Paramcount: Integer): Longword;
    external 'wrapcallback@files:innocallback.dll stdcall';
function  WrapBtnCallback(Callback: TBtnEventProc; ParamCount: Integer): Longword;
    external 'wrapcallback@{tmp}\innocallback.dll stdcall delayload';
function  PBCallBack(P:TPBProc;ParamCount:integer):LongWord;
    external 'wrapcallback@files:innocallback.dll stdcall';

// botva2.dll //////////////////////////////////////////////////////////////////
function  ImgLoad(Wnd :HWND; FileName :PAnsiChar; Left, Top, Width, Height :integer; Stretch, IsBkg :boolean) :Longint;
    external 'ImgLoad@{tmp}\botva2.dll stdcall delayload';
procedure ImgApplyChanges(h:HWND);
    external 'ImgApplyChanges@{tmp}\botva2.dll stdcall delayload';
procedure ImgSetPosition(img :Longint; NewLeft, NewTop, NewWidth, NewHeight :integer);
    external 'ImgSetPosition@files:botva2.dll stdcall';
procedure ImgSetVisiblePart(img:Longint; NewLeft, NewTop, NewWidth, NewHeight : integer);
    external 'ImgSetVisiblePart@files:botva2.dll stdcall';
procedure ImgRelease(img :Longint);
    external 'ImgRelease@{tmp}\botva2.dll stdcall delayload';
procedure gdipShutdown;
    external 'gdipShutdown@{tmp}\botva2.dll stdcall delayload';
function  BtnCreate(hParent:HWND; Left,Top,Width,Height:integer; FileName:PAnsiChar; ShadowWidth:integer; IsCheckBtn:boolean):HWND;
    external 'BtnCreate@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetVisibility(h:HWND; Value:boolean);
    external 'BtnSetVisibility@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetEvent(h:HWND; EventID:integer; Event:Longword);
    external 'BtnSetEvent@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetEnabled(h:HWND; Value:boolean);
    external 'BtnSetEnabled@{tmp}\botva2.dll stdcall delayload';
function  BtnGetChecked(h:HWND):boolean;
    external 'BtnGetChecked@{tmp}\botva2.dll stdcall delayload';
procedure BtnSetChecked(h:HWND; Value:boolean);
    external 'BtnSetChecked@{tmp}\botva2.dll stdcall delayload';

// user32.dll //////////////////////////////////////////////////////////////////
function  SetWindowLong(Wnd: HWnd; Index: Integer; NewLong: Longint): Longint;
    external 'SetWindowLongW@user32.dll stdcall';
function  CallWindowProc(lpPrevWndFunc: Longint; hWnd: HWND; Msg: UINT; wParam, lParam: Longint): Longint;
    external 'CallWindowProcW@user32.dll stdcall';
function  ReleaseCapture(): Longint;
    external 'ReleaseCapture@user32.dll stdcall';
function  SetWindowRgn(hWnd: HWND; hRgn: THandle; bRedraw: Boolean): Integer;
    external 'SetWindowRgn@user32.dll stdcall';

// gdi32.dll //////////////////////////////////////////////////////////////////
function  CreateRoundRectRgn(p1, p2, p3, p4, p5, p6: Integer): THandle;
    external 'CreateRoundRectRgn@gdi32 stdcall';

// kernel32.dll //////////////////////////////////////////////////////////////////
procedure ExitProcess(uExitCode: UINT);
    external 'ExitProcess@kernel32.dll stdcall';
function WaitForSingleObject(hHandle: THandle; dwMilliseconds: DWORD): DWORD;
    external 'WaitForSingleObject@kernel32.dll stdcall';
function GetLastError(): DWORD;
    external 'GetLastError@kernel32.dll stdcall';
function CreateMutexRaw(MutexAttributes: LongInt; InitialOwner: Boolean; Name: String): THandle;
    external 'CreateMutexW@kernel32.dll stdcall';
function CloseHandle(hdl: THandle): Boolean;
    external 'CloseHandle@kernel32.dll stdcall';

//////////////////////////////////////////////////////////////////
const
    bgW = 604;
    bgH = 394;
    licenseViewH = 285;
    licenseViewW = 500;
    Radius = 0;
    BtnClickEventID = 1;
    BN_CLICKED = 0;
    WM_COMMAND = $0111;
    WM_SYSCOMMAND = $0112;
    WM_LBUTTONDOWN = $201;
    CN_BASE = $BC00;
    CN_COMMAND = CN_BASE + WM_COMMAND;
    HTCAPTION = 2;
    SC_MOVE = $F010;
    SC_MINIMIZE = $F020;
    kSetupSelfMutex = '{{2F62DB25-1F58-463E-BB9F-4BF3A54A2D06}';        // 安装包自互斥
    kSetupRejectAppMutex = '{A64AEECF-DF0F-46AD-BEA5-8E674FBB1F7E}';   // 直播姬检测安装包的互斥
    kInstanceRunningMutex = '{12E493A8-BEC2-446D-BE09-CE9CC582D1E6}';  // 安装包检测直播姬的互斥
    kLiveHimeUninstallEntryRegPath = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{#kAppId}_is1';
    kLiveHimeOldUninstallEntryRegPath = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{#kAppId}';
    wbemFlagForwardOnly = $00000020;

var
    bgImg, licenseImg, welcomeTVImg, installingTVImg, pathEditImg, installDirImg, progressImg, progressImgBg, installingTipImg, progressProc: Longint;
    licenseBtn, readLicenseBtn, licenseBackBtn, minBtn, cancelBtn, browseBtn, setupBtn: HWND;
    pathEdit: TEdit;
    licenseView: TRichEditViewer;
    licenseViewClose: Boolean;
    licenseCheck, startLiveHimeCheck, injectOBSPluginCheck, setupCompleteBtn: HWND;
    g_update_mode: Boolean;
    g_old_version_install_dir, g_dpi_suffix, g_dpi_suffix_common, languageName: String;
    g_dpi_scale: Single;
    g_is_high_dpi: Boolean;
    g_app_reject_mutex: THandle;
    installDir_posX, installDir_posY, installDir_width, installDir_height: Integer;
    checkLicense_posX, checkLicense_posY, checkLicense_width, checkLicense_height: Integer;
    readLicenseBtn_posX, readLicenseBtn_posY, readLicenseBtn_width, readLicenseBtn_height: Integer;
    installingTip_posX, installingTip_posY, installingTip_width, installingTip_height: Integer;
    setupBtn_width, setupBtn_height: integer;
    installingTV_width, installingTV_height: integer;
    installDir_offset: Integer;

procedure cancelBtnClick(hBtn:HWND);
begin
    WizardForm.CancelButton.OnClick(WizardForm);
end;

procedure minBtnClick(hBtn:HWND);
begin
    SendMessage(WizardForm.Handle, WM_SYSCOMMAND, SC_MINIMIZE, 0);
end;

procedure WizardMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
    ReleaseCapture();
    SendMessage(WizardForm.Handle, WM_SYSCOMMAND, SC_MOVE + HTCAPTION, 0);
end;

procedure CloseAppRejectMutex();
begin
    if not (g_app_reject_mutex = 0) then begin
        CloseHandle(g_app_reject_mutex);
        g_app_reject_mutex := 0;
    end;
end;

function GetUninstallRegEntry(entry_name: String; var entry_value: String): Boolean;
begin
	if RegQueryStringValue(HKEY_LOCAL_MACHINE, kLiveHimeUninstallEntryRegPath, entry_name, entry_value) then begin
		Result := True;
	end else begin	
		if RegQueryStringValue(HKEY_LOCAL_MACHINE, kLiveHimeOldUninstallEntryRegPath, entry_name, entry_value) then begin
			Result := True;
		end else begin
			Result := False;
			entry_value := ''
		end;
	end;
end;


procedure RemoveOldUninstallEntry();
begin
	RegDeleteKeyIncludingSubkeys(HKEY_LOCAL_MACHINE, kLiveHimeOldUninstallEntryRegPath);
end;

// 创建或删除OBS插件注入配置标识
procedure CreateOrRemoveObsInjectFlag(bCreate:Boolean);
var
    mark_file_path : String;
begin
    // OBS插件注入与否的配置标识，由安装包生成或直播姬主程序生成
    mark_file_path := ExpandConstant('{localappdata}\Temp\');
    
    if bCreate = true then begin
        SaveStringToFile(mark_file_path + 'Inject_OBS', '', False);
    end else begin
        // 删掉标识文件
        DeleteFile(mark_file_path);
    end;
end;


// 获取OBS的安装路径
function GetOBSStudioInstallPath(): String;
var
    InstallDirKey64: String;
    InstallDirKey32: String;
    LastInstallKey64: String;
    LastInstallKey32: String;
    ObsInstallDir: String;
begin
    Result := '';
    // 最近一次安装的OBS版本信息
    //LastInstallKey64 := 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\OBS Studio';
    //LastInstallKey32 := 'SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\OBS Studio';
    // 32位和64位OBS的共同安装路径
    //InstallDirKey32 := 'SOFTWARE\WOW6432Node\OBS Studio';
    InstallDirKey64 := 'SOFTWARE\OBS Studio';
    if RegQueryStringValue(HKEY_LOCAL_MACHINE, InstallDirKey64, '', ObsInstallDir) then begin
        Log('OBS Studio install dir -> ' + ObsInstallDir);
        Result := ObsInstallDir;
    end else
        Log('Cannot find OBS Studio install dir in the reg -> ' + InstallDirKey64);
end;

// 从OBS的安装路径移除直播姬的OBS插件
procedure EraseBililiveOBSPlugins();
var
    ObsInstallDir: String;
    //dst_dll_x86: String;
    dst_dll_x64: String;
begin
    ObsInstallDir := GetOBSStudioInstallPath();
    if ObsInstallDir <> '' then begin
        //dst_dll_x86 := ExpandConstant(ObsInstallDir + '\obs-plugins\32bit\{#kBililiveOBSPluginName}');
        dst_dll_x64 := ExpandConstant(ObsInstallDir + '\obs-plugins\64bit\{#kBililiveOBSPluginName}');
        
        //Log('delete bililive plugin -> "' + dst_dll_x86 + '"');
        //DeleteFile(dst_dll_x86);
        
        Log('delete bililive plugin -> "' + dst_dll_x64 + '"');
        DeleteFile(dst_dll_x64);
    end;
end;

// 将直播姬的OBS插件拷贝到OBS Studio的安装路径中
function CopyOrRemoveLivehimePluginsToOBSInstallPath(): Boolean;
var
    ObsInstallDir: String;
    src_dll_x86: String;
    src_dll_x64: String;
    dst_dll_x86: String;
    dst_dll_x64: String;
    mark_file_path : String;
begin
    Result := False;
    ObsInstallDir := GetOBSStudioInstallPath();
    if ObsInstallDir <> '' then begin
    
        // OBS插件注入与否的配置标识，由安装包生成或直播姬主程序生成
        mark_file_path := ExpandConstant('{localappdata}\Temp\Inject_OBS');
        
        //src_dll_x86 := ExpandConstant('{app}\plugins\{#kBililiveOBSPluginName}');
        src_dll_x64 := ExpandConstant('{app}\plugins\{#kBililiveOBSPluginName}');
        //dst_dll_x86 := ExpandConstant(ObsInstallDir + '\obs-plugins\32bit\{#kBililiveOBSPluginName}');
        dst_dll_x64 := ExpandConstant(ObsInstallDir + '\obs-plugins\64bit\{#kBililiveOBSPluginName}');
        
        // 判断标识存在与否，存在才拷贝，不存在就删除
        if FileExists(mark_file_path) = true then begin
            //Log('copy "' + src_dll_x86 + '" to "' + dst_dll_x86 + '"');
            //FileCopy(src_dll_x86, dst_dll_x86, False);            
            
            Log('copy "' + src_dll_x64 + '" to "' + dst_dll_x64 + '"');
            FileCopy(src_dll_x64, dst_dll_x64, False);        
        end else begin
            EraseBililiveOBSPlugins();
        end;
        
        Result := True;
    end;
end;

// install finished //////////////////////////////////////////////////////////////////
procedure setupCompleteBtnClick(hBtn:HWND);
begin
   
    RunClickFlag(True);
    // 如果用户勾选了OBS插件注入，则生成配置标识，否则删掉
    CreateOrRemoveObsInjectFlag(BtnGetChecked(injectOBSPluginCheck));
    
    // 根据标识存在与否来决定是删插件还是安装/更新插件
    CopyOrRemoveLivehimePluginsToOBSInstallPath();

    // 安装结束后，在启动直播姬之前释放互斥
    CloseAppRejectMutex();
    WizardForm.NextButton.OnClick(WizardForm);
end;

procedure exitBtnClick(hBtn:HWND);
begin
    // Exit;
	RunClickFlag(False);
    ExitProcess(0);
end;

function DpToPx(Dp: Integer): Integer;
begin
    if g_is_high_dpi then begin
        Result := Trunc(Dp * g_dpi_scale);
    end else begin
        Result := Dp;
    end;
end;

procedure installFinished();
var
    old_bgImg : LongInt;
    inject_w : Integer;
    run_w : Integer;
    pendding : Integer;
    check_area_w : Integer;
    x : Integer;

begin
    old_bgImg := bgImg;

    bgImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\bg3' + g_dpi_suffix),
        0, 0, DpToPx(bgW), DpToPx(bgH),
        true, true);

    setupCompleteBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW - 177)/2), DpToPx(256), DpToPx(177), DpToPx(62),
        ExpandConstant('{tmp}\installCompleteBtn' + g_dpi_suffix),
        1, False)
    BtnSetEvent(setupCompleteBtn, BtnClickEventID, WrapBtnCallback(@setupCompleteBtnClick, 1));

    x := (bgW - 239)/2;
    injectOBSPluginCheck := BtnCreate(
        WizardForm.Handle,
        DpToPx(x), DpToPx(330), DpToPx(239), DpToPx(15),
        ExpandConstant('{tmp}\checkObsInject' + g_dpi_suffix), 1, true)
    BtnSetChecked(injectOBSPluginCheck, true);

  

    BtnSetEvent(cancelBtn, BtnClickEventID, WrapBtnCallback(@exitBtnClick, 1));

    ImgRelease(old_bgImg)
    ImgRelease(installingTVImg)
    ImgRelease(progressImg)
    ImgRelease(progressImgBg)

    RemoveOldUninstallEntry()
end;

// installing page //////////////////////////////////////////////////////////////////
procedure installingPage();
var
    old_bgImg : LongInt;

begin
    old_bgImg := bgImg;

    BtnSetVisibility(setupBtn,false)
    BtnSetVisibility(licenseCheck,false)
    BtnSetVisibility(licenseBtn,false)
    BtnSetVisibility(readLicenseBtn, false)
    BtnSetVisibility(browseBtn,false)
    BtnSetVisibility(licenseBackBtn,false)
    pathEdit.Hide();

    bgImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\bg1' + g_dpi_suffix_common),
        0, 0, DpToPx(bgW), DpToPx(bgH),
        True, True);
    installingTVImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingTV' + g_dpi_suffix),
        DpToPx((bgW-165)/2-25), DpToPx(84), DpToPx(installingTV_width), DpToPx(installingTV_height),
        True, True);

    installingTipImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingTip' + g_dpi_suffix),
        DpToPx(installingTip_posX), DpToPx(installingTip_posY), DpToPx(installingTip_width), DpToPx(installingTip_height),
        True, True);
    progressImgBg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingProcessBg' + g_dpi_suffix_common),
        DpToPx((bgW - 570)/2), DpToPx(360), DpToPx(570), DpToPx(6),
        True, True);
    progressImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installingProcess' + g_dpi_suffix_common),
        DpToPx((bgW - 570)/2), DpToPx(360), 0, 0,
        True, True);

    // 在释放上一页的图片之前，先把当前页的图片加载出来，
    // 以免界面出现闪烁，下同
    ImgRelease(old_bgImg)
    ImgRelease(welcomeTVImg)
    ImgRelease(installDirImg)
    ImgRelease(pathEditImg)
end;

// welcome page //////////////////////////////////////////////////////////////////
procedure lockLicenseBtnClick(hBtn:HWND);
begin
    if licenseViewClose = true then begin
        BtnSetVisibility(setupBtn, false)
        BtnSetVisibility(licenseCheck, false)
        BtnSetVisibility(licenseBtn, false)
        BtnSetVisibility(readLicenseBtn, false)
        BtnSetVisibility(browseBtn, false)
        pathEdit.Hide;

        licenseImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\bg2' + g_dpi_suffix_common),
            0, 0, DpToPx(bgW), DpToPx(bgH),
            True, True);

        ImgRelease(bgImg)
        ImgRelease(welcomeTVImg)
        ImgRelease(installDirImg)
        ImgRelease(pathEditImg)

        ImgApplyChanges(WizardForm.Handle);

        licenseView.Height := DpToPx(licenseViewH);
        licenseView.SelStart := 0;
        licenseView.SelLength := 0;
        BtnSetVisibility(licenseBackBtn, true)
        licenseViewClose := false
    end else begin
        licenseView.Height := 0
        BtnSetVisibility(licenseBackBtn, false)
        licenseViewClose := true

        bgImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\bg1' + g_dpi_suffix_common),
            0, 0, DpToPx(bgW), DpToPx(bgH),
            True, True);
        welcomeTVImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\welcomeTV' + g_dpi_suffix_common),
            DpToPx((bgW-165)/2), DpToPx(84), DpToPx(165), DpToPx(141),
            True, True);
        pathEditImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\pathEditBg' + g_dpi_suffix_common),
            DpToPx(120 + installDir_offset), DpToPx(342), DpToPx(360), DpToPx(30),
            True, True);
        installDirImg := ImgLoad(
            WizardForm.Handle,
            ExpandConstant('{tmp}\installDir' + g_dpi_suffix),
            DpToPx(installDir_posX), DpToPx(installDir_posY), DpToPx(installDir_width), DpToPx(installDir_height),
            True, True);

        BtnSetVisibility(setupBtn, true)
        BtnSetVisibility(licenseCheck, true)
        BtnSetVisibility(licenseBtn, true)
        BtnSetVisibility(readLicenseBtn, true)
        BtnSetVisibility(browseBtn, true)

        ImgRelease(licenseImg)
        ImgApplyChanges(WizardForm.Handle);
        
        // 等到页面上其他图片和控件加载完后，再显示这个编辑框，
        // 防止界面闪烁
        pathEdit.Show();
    end;
end;

procedure pathEditChange(Sender: TObject);
begin
    WizardForm.DirEdit.text:=pathEdit.Text;
end;

procedure browseBtnClick(hBtn:HWND);
begin
    WizardForm.DirBrowseButton.OnClick(WizardForm);
    pathEdit.text := WizardForm.DirEdit.text;
end;

procedure licenseCheckClick(hBtn:HWND);
begin
    if BtnGetChecked(licenseCheck)=true then
    begin
        BtnSetEnabled(setupBtn,true)
    end else begin
        BtnSetEnabled(setupBtn,false)
    end
end;

// Best efforts only...
function IsInstallLocationIllegal(program_dir_path: String): Boolean;
begin
    Result := ExtractFileDrive(program_dir_path) = '';
end;

function IsInstallLocationDriveRoot(program_dir_path: String): Boolean;
begin
    Result := program_dir_path = ExtractFileDir(program_dir_path);
end;

function IsInstallLocationPotentialRisk(program_dir: String): Boolean;
var
    program_dir_name: String;
    program_dir_path: String;
begin
    program_dir_path := program_dir;
    while program_dir_path <> ExtractFileDir(program_dir_path) do
    begin
        program_dir_name := ExtractFileName(program_dir_path);
        if (program_dir_name = 'bililive') or (program_dir_name = 'Bilibili Studio') then begin
            Result := False;
            Exit;
        end;
        program_dir_path := ExtractFileDir(program_dir_path);
    end;
    Result := True;
end;

procedure setupBtnclick(hBtn:HWND);
var
    program_dir_path: String;
begin
    program_dir_path := RemoveBackslashUnlessRoot(pathEdit.Text);
    InstallClickFlag(True);
    if IsInstallLocationIllegal(program_dir_path) then begin
        MsgBox(CustomMessage('InvalidInstallPath'), mbError, MB_OK);
        pathEdit.Text := ExpandConstant('{#SetupSetting("DefaultDirName")}');
        Exit;
    end;

    // Not allowed installing on drive root.
    if IsInstallLocationDriveRoot(program_dir_path) then begin
        MsgBox(CustomMessage('CantIntsallInRootFolder'), mbError, MB_OK);
        pathEdit.Text := ExpandConstant('{#SetupSetting("DefaultDirName")}');
        Exit;
    end;

    // Disclaimers.
    if IsInstallLocationPotentialRisk(program_dir_path) then begin
        if MsgBox(CustomMessage('MayConflictWithOther'), mbConfirmation, MB_YESNO) <> IDYES then begin
            pathEdit.Text := ExpandConstant('{#SetupSetting("DefaultDirName")}');
            Exit;
        end;
    end;

    WizardForm.NextButton.OnClick(WizardForm);
end;

function NextButtonClick(CurPageID: Integer): Boolean;
var
    install_path: String;
begin
    if CurPageID = wpSelectDir then begin
        if not g_update_mode then begin
            install_path := WizardForm.DirEdit.text;
            install_path := AddBackSlash(AddBackSlash(install_path) + '{#kAppVersion}');
            WizardForm.DirEdit.text := install_path;
        end;
    end;

    Result := True;
end;

procedure welcomePage();
begin
    if g_installed_app_version <> '' then begin
	   g_installed_boolean := True;
	end;
    bgImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\bg1' + g_dpi_suffix_common),
        0, 0, DpToPx(bgW), DpToPx(bgH),
        True, True);
    welcomeTVImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\welcomeTV' + g_dpi_suffix_common),
        DpToPx((bgW-165)/2), DpToPx(84), DpToPx(165), DpToPx(141),
        True, True);

    setupBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW - 223)/2), DpToPx(216), DpToPx(setupBtn_width), DpToPx(setupBtn_height),
        ExpandConstant('{tmp}\setupBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(setupBtn,BtnClickEventID,WrapBtnCallback(@setupBtnclick,1));

    licenseCheck := BtnCreate(
        WizardForm.Handle,
        DpToPx(checkLicense_posX), DpToPx(checkLicense_posY), DpToPx(checkLicense_width), DpToPx(checkLicense_height),
        ExpandConstant('{tmp}\checkLicense' + g_dpi_suffix), 1, true)
    BtnSetEvent(licenseCheck,BtnClickEventID,WrapBtnCallback(@licenseCheckClick,1));
    BtnSetChecked(licenseCheck,true)

    readLicenseBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx(readLicenseBtn_posX), DpToPx(readLicenseBtn_posY), DpToPx(readLicenseBtn_width), DpToPx(readLicenseBtn_height),
        ExpandConstant('{tmp}\readLicenseBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(readLicenseBtn,BtnClickEventID,WrapBtnCallback(@lockLicenseBtnClick,1));

    licenseBackBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx((bgW - 80) / 2), DpToPx(350), DpToPx(80), DpToPx(30),
        ExpandConstant('{tmp}\licenseBackBtn' + g_dpi_suffix), 1, False)
    BtnSetEvent(licenseBackBtn,BtnClickEventID,WrapBtnCallback(@lockLicenseBtnClick,1));
    BtnSetVisibility(licenseBackBtn,false)

    licenseView := TRichEditViewer.Create(WizardForm);
    with licenseView do
        begin
            Parent := WizardForm;
            ReadOnly:= true;
            SCROLLBARS:= ssVertical;

            if(languageName = 'zh_CN') then begin
                Font.Name:='微软雅黑'
            end else begin
                Font.Name:='Microsoft YaHei'
            end;   
           
            Font.Size := 9;
            Color:=clWhite;
            BorderStyle:= bsNone;
            SetBounds(DpToPx((bgW - licenseViewW) / 2), DpToPx(50), DpToPx(licenseViewW), DpToPx(licenseViewH))
            if(languageName = 'zh_CN') then begin
                Lines.LoadFromFile(ExpandConstant('{tmp}\license.txt'));
            end else if(languageName = 'en_US') then begin
                Lines.LoadFromFile(ExpandConstant('{tmp}\license_en.txt'));
            end else if(languageName = 'id_ID') then begin
                Lines.LoadFromFile(ExpandConstant('{tmp}\license_india.txt'));
            end else if(languageName = 'th_TH') then begin
                Lines.LoadFromFile(ExpandConstant('{tmp}\license_thai.txt'));
            end;   
            TabStop:=false;
            Height := 0;
        end;


    installDirImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\installDir' + g_dpi_suffix),
        DpToPx(installDir_posX), DpToPx(installDir_posY), DpToPx(installDir_width), DpToPx(installDir_height),
        True, true);
    pathEditImg := ImgLoad(
        WizardForm.Handle,
        ExpandConstant('{tmp}\pathEditBg' + g_dpi_suffix_common),
        DpToPx(120 + installDir_offset), DpToPx(342), DpToPx(360), DpToPx(30),
        True, true);
    pathEdit := TEdit.Create(WizardForm);
    with pathEdit do
        begin
            Parent := WizardForm;
            text :=WizardForm.DirEdit.text;

            if(languageName = 'zh_CN') then begin
                Font.Name:='微软雅黑'
            end else begin
                Font.Name:='Microsoft YaHei'
            end;   

            Font.Size := 10;
            BorderStyle:=bsNone;
            SetBounds(DpToPx(126 + installDir_offset), DpToPx(348), DpToPx(348), DpToPx(18))
            OnChange:=@pathEditChange;
            Color := $00FFFFFF;
            TabStop :=false;
        end;

    browseBtn := BtnCreate(
        WizardForm.Handle,
        DpToPx(480 + installDir_offset), DpToPx(342), DpToPx(80), DpToPx(30),
        ExpandConstant('{tmp}\browseBtn' + g_dpi_suffix_common), 1, False)
    BtnSetEvent(browseBtn,BtnClickEventID,WrapBtnCallback(@browseBtnClick,1));
end;

procedure CurPageChanged(CurPageID: Integer);
var
    param: Longint;
begin
    // Don't simply make the next button invisible, we need to simulate click event on next button
    // to proceed installation automatically.
    WizardForm.NextButton.Height := 0;
    WizardForm.CancelButton.Height := 0;
    WizardForm.BackButton.Height:=0;

    if CurPageID = wpWelcome then begin
        welcomePage();
    end;

    if CurPageID = wpReady then begin
        param := 0 or BN_CLICKED shl 16;
        PostMessage(WizardForm.NextButton.Handle, CN_COMMAND, param, 0);
    end;

    if CurPageID = wpInstalling then begin
        installingPage();
    end;

    if CurPageID = wpFinished then begin
        //installFinished();
	   RunClickFlag(True);
      // 如果用户勾选了OBS插件注入，则生成配置标识，否则删掉
      CreateOrRemoveObsInjectFlag(true);
    
      // 根据标识存在与否来决定是删插件还是安装/更新插件
      CopyOrRemoveLivehimePluginsToOBSInstallPath();

      // 安装结束后，在启动直播姬之前释放互斥
      CloseAppRejectMutex();
      WizardForm.NextButton.OnClick(WizardForm);
    end;

    ImgApplyChanges(WizardForm.Handle)
end;

function ShouldSkipPage(PageID: Integer): Boolean;
begin
    Result := True;

    // Display installing page only in update mode.
    if g_update_mode then begin
        if (PageID = wpInstalling) then begin
            Result := False;
        end;

        if PageID = wpFinished then begin
            // 判断一下，如果没有特定标识，则把obs插件目录中已经注入的dll给删掉，
            // 如果标识存在则将OBS插件复制过去，更新一波
            CopyOrRemoveLivehimePluginsToOBSInstallPath();
            
            CloseAppRejectMutex();
			RemoveOldUninstallEntry();
        end;
        Exit;
    end;

    if (PageID = wpWelcome) or
       (PageID = wpInstalling) or
	   (PageID = wpSelectDir) or
       (PageID = wpFinished) then
        Result := false;
end;

procedure ShapeForm(aForm: TForm; edgeSize: integer); // 圆角
var
    FormRegion:LongWord;
begin
    FormRegion:=CreateRoundRectRgn(0, 0, aForm.Width, aForm.Height, edgeSize, edgeSize);
    SetWindowRgn(aForm.Handle, FormRegion, True);
end;

function PBProc(handle:hWnd; Msg, wParam, lParam:Longint):Longint;
var
    pr, i1, i2 : Extended;
    w : Integer;
    h : Integer;
begin
    Result := CallWindowProc(progressProc, handle, Msg, wParam, lParam);
    if (Msg = $402) and (WizardForm.ProgressGauge.Position > WizardForm.ProgressGauge.Min) then begin
        i1 := WizardForm.ProgressGauge.Position - WizardForm.ProgressGauge.Min;
        i2 := WizardForm.ProgressGauge.Max - WizardForm.ProgressGauge.Min;
        pr := i1 / i2;
        w := Round(570 * pr);
        ImgSetPosition(progressImg, DpToPx((bgW - 570)/2), DpToPx(360), DpToPx(w), DpToPx(6));

        h := 6;
        if g_is_high_dpi then begin
            w := w * 2;
            h := 12;
        end;

        ImgSetVisiblePart(progressImg, 0, 0, w, h);
        ImgApplyChanges(WizardForm.Handle);
    end;
end;

procedure initWizardForm();
var
    MainLabel: TLabel;
begin
    WizardForm.OuterNotebook.Hide();
    WizardForm.Bevel.Hide();
    WizardForm.BorderStyle := bsnone;
    WizardForm.Position := poScreenCenter;
    WizardForm.Width := DpToPx(bgW) + 1;
    WizardForm.Height := DpToPx(bgH) + 1;
    WizardForm.Color := clWhite;
    ShapeForm(WizardForm, Radius);

    // 只是用来处理拖动的透明控件
    MainLabel := TLabel.Create(WizardForm);
    MainLabel.Parent := WizardForm;
    MainLabel.AutoSize := False;
    MainLabel.Left := 0;
    MainLabel.Top := 0;
    MainLabel.Width := WizardForm.Width;
    MainLabel.Height := WizardForm.Height;
    MainLabel.Caption := '';
    MainLabel.Transparent := True;
    MainLabel.OnMouseDown := @WizardMouseDown;

    cancelBtn := BtnCreate(
        WizardForm.Handle,
        (DpToPx(bgW) - DpToPx(32)), DpToPx(2), DpToPx(30), DpToPx(30),
        ExpandConstant('{tmp}\closeBtn' + g_dpi_suffix_common), 1, False)
    BtnSetEvent(cancelBtn,BtnClickEventID,WrapBtnCallback(@cancelBtnClick,1));
    minBtn := BtnCreate(
        WizardForm.Handle,
        (DpToPx(bgW) - DpToPx(62)), DpToPx(2), DpToPx(30), DpToPx(30),
        ExpandConstant('{tmp}\minBtn' + g_dpi_suffix_common), 1, False)
    BtnSetEvent(minBtn,BtnClickEventID,WrapBtnCallback(@minBtnClick,1));

    licenseViewClose := true;
    progressProc:=SetWindowLong(WizardForm.ProgressGauge.Handle, -4, PBCallBack(@PBProc, 4));
end;

function ValidateWin7OrLater(): Boolean;
var
    os_ver: TWindowsVersion;
begin
    Result := True;
    GetWindowsVersionEx(os_ver);
    if (os_ver.Major < 6) or
       ((os_ver.Major = 6) and (os_ver.Minor = 0)) then begin
        SuppressibleMsgBox(FmtMessage(CustomMessage('WindowsRunLevel'), [ExpandConstant('{#kAppName}')]), mbCriticalError, MB_OK, IDOK);
        Result := False;
    end;
end;

function GetNumber(var temp: String): Integer;
var
    part: String;
    pos1: Integer;
begin
    if Length(temp) = 0 then begin
        Result := -1;
        Exit;
    end;

    pos1 := Pos('.', temp);

    if (pos1 = 0) then begin
        Result := StrToIntDef(temp, 0);
        temp := '';
    end else begin
        part := Copy(temp, 1, pos1 - 1);
        temp := Copy(temp, pos1 + 1, Length(temp));
        Result := StrToIntDef(part, 0);
    end;
end;

function CompareInner(var temp1, temp2: String): Integer;
var
    num1, num2: Integer;
begin
    num1 := GetNumber(temp1);
    num2 := GetNumber(temp2);
    if (num1 = -1) or (num2 = -1) then begin
        Result := 0;
        Exit;
    end;

    if (num1 > num2) then begin
        Result := 1;
    end else if (num1 < num2) then begin
        Result := -1;
    end else begin
        Result := CompareInner(temp1, temp2);
    end;
end;

// positive, if str1 > str2
// 0, if str1 == str2
// negative, if str1 < str2
function CompareVersion(str1, str2: String): Integer;
var
    temp1, temp2: String;
begin
    // 对str进行一下正则判断最好
    temp1 := str1;
    temp2 := str2;
    Result := CompareInner(temp1, temp2);
end;

function StartsWith(SubStr, S: String):Boolean;
begin
    Result:= Pos(SubStr, S) = 1;
end;

function StringReplace(S, oldSubString, newSubString: String) : String;
var
    stringCopy : String;
begin
    stringCopy := S;
    StringChange(stringCopy, oldSubString, newSubString);
    Result := stringCopy;
end;

function GetCommandlineParam(inParamName: String):String;
var
    paramNameAndValue: String;
    i: Integer;
begin
    Result := '';
    for i:= 0 to ParamCount do
    begin
        paramNameAndValue := ParamStr(i);
        if (StartsWith(inParamName, paramNameAndValue)) then begin
            Result := StringReplace(paramNameAndValue, inParamName + '=', '');
            break;
        end;
    end;
end;

function HasCommandlineSwitch(switch_name: String): Boolean;
var
    i: Integer;
    paramNameAndValue: String;
begin
    for i:= 0 to ParamCount do
    begin
        paramNameAndValue := ParamStr(i);
        if (StartsWith(switch_name, paramNameAndValue)) then begin
            Result := True;
            break;
        end;
    end;
end;

// This is the first step invoked by our installer.
// Returns False to abort the installation.
function InitializeSetup: Boolean;
var
    installed_app_version: String;
    install_location: String;
    retry_count: Integer;
begin
    // 检查是否已经存在安装程序
    if CheckForMutexes(kSetupSelfMutex) then begin
        Result := False;
        Exit;
    end;
    
    CreateMutex(kSetupSelfMutex);
    // 这个互斥需要在安装程序退出之前释放，所以不能用内建的互斥函数
    g_app_reject_mutex := CreateMutexRaw(0, False, kSetupRejectAppMutex);

    // For being accurate, we should call WaitForSingleObject() on Bilibili Studio's process handle;
    // However, it might be overkill in real world, much less potential risks it involes.
    if HasCommandlineSwitch('--hot-update') then begin
        // Wait Bilibili Studio process to exit.
        While (CheckForMutexes(kInstanceRunningMutex)) and (retry_count < 5) do begin
            Sleep(1500);
            retry_count := retry_count + 1;
        end;
    end;

    // We only allow Bilibili Studio running on Windows 7 or later.
    if not ValidateWin7OrLater() then begin
        Exit;
    end;

    // We here use the same mutex used by bililive itself to prevent running multiple instances.
    while CheckForMutexes(kInstanceRunningMutex) do begin
        if Msgbox(FmtMessage(CustomMessage('ApplicationRuningWhenInstall'), [ExpandConstant('{#kAppName}')]),
                  mbConfirmation, MB_YESNO) = idNO then begin
            Exit;
        end
    end;
	
    g_installed_app_version := '';
    if GetUninstallRegEntry('DisplayVersion', installed_app_version) then begin
		g_installed_app_version := installed_app_version;
        if CompareVersion(installed_app_version, '1.0.1.638') < 0 then begin
            MsgBox(FmtMessage(CustomMessage('IncompatibleVersion'), [ExpandConstant('{#kAppName}'), installed_app_version]),
                   mbCriticalError, MB_OK);
            Exit;
        end;

        if CompareVersion(installed_app_version, '{#kAppVersion}') > 0 then begin
            if not HasCommandlineSwitch('--force-install') then begin
                MsgBox(FmtMessage(CustomMessage('HasHigerVersion'), [ExpandConstant('{#kAppName}'), installed_app_version]), mbCriticalError, MB_OK);
                Exit;
            end;
        end;

        // If the install location is not empty yet inaccessible, we fallback to normal mode.
        if GetUninstallRegEntry('InstallLocation', install_location) then begin
            install_location := ExtractFileDir(RemoveBackslashUnlessRoot(install_location));
            if (Length(install_location) <> 0) and (DirExists(install_location))  then begin
                g_update_mode := True;
                g_old_version_install_dir := install_location;
            end;
        end;
    end;

    Result := True;
end;

procedure DeinitializeSetup();
begin
    CloseAppRejectMutex();
    gdipShutdown();
end;

procedure ExtractImgWithSuffix(dpi_suffix: String);
begin
    ExtractTemporaryFile('bg1' + g_dpi_suffix_common);
    ExtractTemporaryFile('bg2' + g_dpi_suffix_common);
    //ExtractTemporaryFile('bg3' + dpi_suffix);
    ExtractTemporaryFile('closeBtn' + g_dpi_suffix_common);
    ExtractTemporaryFile('minBtn' + g_dpi_suffix_common);
    ExtractTemporaryFile('setupBtn' + dpi_suffix);
    //ExtractTemporaryFile('checkRun' + dpi_suffix);
    //ExtractTemporaryFile('checkObsInject' + dpi_suffix);
    ExtractTemporaryFile('checkLicense' + dpi_suffix);
    ExtractTemporaryFile('installingTV' + dpi_suffix);
    //ExtractTemporaryFile('installCompleteBtn' + dpi_suffix);
    ExtractTemporaryFile('installingProcess' + g_dpi_suffix_common);
    ExtractTemporaryFile('installingProcessBg' + g_dpi_suffix_common);
    ExtractTemporaryFile('welcomeTV' + g_dpi_suffix_common);
    ExtractTemporaryFile('readLicenseBtn' + dpi_suffix);
    ExtractTemporaryFile('licenseBackBtn' + dpi_suffix);
    ExtractTemporaryFile('pathEditBg' + g_dpi_suffix_common);
    ExtractTemporaryFile('installDir' + dpi_suffix);
    ExtractTemporaryFile('browseBtn' + g_dpi_suffix_common);
    ExtractTemporaryFile('installingTip' + dpi_suffix);

    if(languageName = 'zh_CN') then begin
        ExtractTemporaryFile('license.txt');
    end else if(languageName = 'en_US') then begin
        ExtractTemporaryFile('license_en.txt');
    end else if(languageName = 'id_ID') then begin
        ExtractTemporaryFile('license_india.txt');
    end else if(languageName = 'th_TH') then begin
        ExtractTemporaryFile('license_thai.txt');
    end;   
end;


procedure CheckDPI();
var
    current_dpi, standard_dpi: Integer;
begin
    current_dpi := WizardForm.Font.PixelsPerInch;
    standard_dpi := 96;   
    if (current_dpi > standard_dpi) then begin
        if(languageName = 'zh_CN') then begin
            g_dpi_suffix := '_2x.png';
        end else if(languageName = 'en_US') then begin
            g_dpi_suffix := '_2x_en.png';
        end else if(languageName = 'id_ID') then begin
            g_dpi_suffix := '_2x_india.png';
        end else if(languageName = 'th_TH') then begin
            g_dpi_suffix := '_2x_thai.png';
        end else begin
            g_dpi_suffix := '_2x_en.png';
        end;
            g_dpi_suffix_common := '_2x.png';
            g_dpi_scale := current_dpi * 1.0 / standard_dpi;
            g_is_high_dpi := True;
    end else begin
         if(languageName = 'zh_CN') then begin
            g_dpi_suffix := '.png';
        end else if(languageName = 'en_US') then begin
            g_dpi_suffix := '_en.png';
        end else if(languageName = 'id_ID') then begin
            g_dpi_suffix := '_india.png';
        end else if(languageName = 'th_TH') then begin
            g_dpi_suffix := '_thai.png';
        end else begin
            g_dpi_suffix := '_en.png';
        end;
        g_dpi_suffix_common := '.png';
        g_dpi_scale := 1;
        g_is_high_dpi := False;
    end;
end;

procedure SetImageInfo();
begin   
    installDir_posY := 350;
    checkLicense_posY := 290;
    readLicenseBtn_posY := 291;
    installingTip_posY := 345;
    installDir_offset := 0;

    if(languageName = 'zh_CN') then begin
        installDir_posX := 45;
        installDir_width := 66;
        installDir_height := 15;

        checkLicense_posX := (bgW-211)/2;
        checkLicense_width := 119;
        checkLicense_height := 15;

        readLicenseBtn_posX := (bgW-211)/2 + 119;
        readLicenseBtn_width := 92;
        readLicenseBtn_height := 14;

        installingTip_posX := (bgW - 570)/2;
        installingTip_width := 146;
        installingTip_height := 12;

        setupBtn_width := 223;
        setupBtn_height := 69;

        installingTV_width := 211;
        installingTV_height := 186;

    end else if(languageName = 'en_US') then begin
        installDir_posX := 25;
        installDir_width := 106;
        installDir_height := 14;

        checkLicense_posX := (bgW-211-93)/2;
        checkLicense_width := 170;
        checkLicense_height := 14;

        readLicenseBtn_posX := (bgW-211)/2 + 128;
        readLicenseBtn_width := 145;
        readLicenseBtn_height := 14;

        installingTip_posX := (bgW - 570)/2;
        installingTip_width := 55;
        installingTip_height := 14;

        setupBtn_width := 223;
        setupBtn_height := 69;

        installingTV_width := 211;
        installingTV_height := 184 * 211 / 255;

        installDir_offset := 15;

    end else if(languageName = 'id_ID') then begin
        installDir_posX := 15;
        installDir_width := 114;
        installDir_height := 14;

        checkLicense_posX := (bgW-211-128)/2;
        checkLicense_width := 210;
        checkLicense_height := 14;

        readLicenseBtn_posX := (bgW-211)/2 + 148;
        readLicenseBtn_width := 165;
        readLicenseBtn_height := 14;

        installingTip_posX := (bgW - 570)/2;
        installingTip_width := 90;
        installingTip_height := 14;

        setupBtn_width := 233;
        setupBtn_height := 69 * 223/ 300;

        installingTV_width := 211;
        installingTV_height := 184 * 211 / 255;

        installDir_offset := 15;

    end else if(languageName = 'th_TH') then begin
        installDir_posX := 25;
        installDir_width := 97;
        installDir_height := 16;

        checkLicense_posX := (bgW-211-136)/2;
        checkLicense_width := 193;
        checkLicense_height := 14;

        readLicenseBtn_posX := (bgW-211)/2 + 125;
        readLicenseBtn_width := 180;
        readLicenseBtn_height := 15;

        installingTip_posX := (bgW - 570)/2;
        installingTip_width := 64;
        installingTip_height := 16;

        setupBtn_width := 223;
        setupBtn_height := 69 * 223 / 212;

        installingTV_width := 211;
        installingTV_height := 184 * 211 / 255;

        installDir_offset := 10;

    end;
end;


procedure InitializeWizard();
var
    install_path: String;
begin
    languageName := ActiveLanguage();
    CheckDPI();
    ExtractImgWithSuffix(g_dpi_suffix);
    SetImageInfo();
    initWizardForm();
    if g_update_mode then begin
        install_path := AddBackslash(AddBackslash(g_old_version_install_dir) + '{#kAppVersion}');
        WizardForm.DirEdit.text := install_path;
    end;
end;

procedure TerminateProcess(ProcName: String);
var
    WbemLocator: Variant;
    WMIService: Variant;
    WbemObjectSet: Variant;
    WbemObject: Variant;
    i: Integer;
begin;
    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := WbemLocator.ConnectServer('localhost', 'root\CIMV2');
    WbemObjectSet := WMIService.ExecQuery('SELECT * FROM Win32_Process Where Name="' + ProcName + '"');
    if not VarIsNull(WbemObjectSet) and (WbemObjectSet.Count > 0) then begin
        for i := 0 to WbemObjectSet.Count - 1 do
        begin
            WbemObject := WbemObjectSet.ItemIndex(i);
            if not VarIsNull(WbemObject) then begin
                WbemObject.Terminate();
            end;
        end;
    end;
end;

procedure CopyLauncherExe();
var
    src_exe_path: String;
    tmp_exe_path: String;
    dest_exe_path: String;
begin
    src_exe_path := ExpandConstant('{app}\Bilibili Studio.exe');
    tmp_exe_path := ExpandConstant('{app}\..\new_Bilibili Studio.exe');
    dest_exe_path := ExpandConstant('{app}\..\Bilibili Studio.exe');

    FileCopy(src_exe_path, tmp_exe_path, False);
    DelayDeleteFile(dest_exe_path, 3);

    if not RenameFile(tmp_exe_path, dest_exe_path) then begin
        Log('Failed to swap the launcher exe, trying to terminate process now...');
        // Take terminating processes as the last resort.
        TerminateProcess('Bilibili Studio.exe');
        DelayDeleteFile(dest_exe_path, 5);
        RenameFile(tmp_exe_path, dest_exe_path);
    end;
end;

// Hard coded for version format like 1.1.0.123
function GuessVersionDir(dir_name: String): Boolean;
var
    test_count: Integer;
    i: Integer;
    cut_len: Integer;
    tmp: String;
    ver_cp: String;
begin
    test_count := 0;
    tmp := dir_name;
    while tmp <> '' do
    begin
        i := Pos('.', tmp);
        cut_len := i - 1;
        if i = 0 then begin
            cut_len := Length(tmp);
        end;
        ver_cp := Copy(tmp, 1, cut_len);
        if StrToIntDef(ver_cp, -1) < 0 then begin
            Exit;
        end;
        if i = 0 then begin
            tmp := '';
        end else begin
            tmp := Copy(tmp, i + 1, Length(tmp) - i);
            test_count := test_count + 1;
        end;
    end;
    Result := test_count = 3;
end;

procedure RemoveObsoleteProgramDirs();
var
    program_dir_pattern: String;
    file_find_rec: TFindRec;
    target_dirs: array of String;
    num_found: Integer;
    i: Integer;
    dir_name_to_purge: String;
    dir_name_for_purge: String;
begin
    program_dir_pattern := ExpandConstant('{app}\..\*');
    if FindFirst(program_dir_pattern, file_find_rec) then begin
        // yeah, hard-coded, bite me?!
        SetArrayLength(target_dirs, 100);
        try
            repeat
                if ((file_find_rec.Attributes and FILE_ATTRIBUTE_DIRECTORY) <> 0) and
                   (file_find_rec.Name <> '.') and
                   (file_find_rec.Name <> '..') and
                   (file_find_rec.Name <> '{#kAppVersion}') then begin
                    if GuessVersionDir(file_find_rec.Name) then begin
                        Log('Tracked ' + file_find_rec.Name);
                        target_dirs[num_found] := file_find_rec.Name;
                        num_found := num_found + 1;
                    end;
                end;
            until not FindNext(file_find_rec);
        finally
            FindClose(file_find_rec);
        end;

        // Let's take them down.
        if num_found > 0 then begin
            for i := 0 to num_found - 1 do
            begin
                dir_name_to_purge := ExpandConstant('{app}\..\') + target_dirs[i];
                dir_name_for_purge := ExpandConstant('{app}\..\') + target_dirs[i] + '_';
                if not RenameFile(dir_name_to_purge, dir_name_for_purge) then begin
                    Log('Can''t rename ' + dir_name_to_purge);
                    continue;
                end;
                DelTree(dir_name_for_purge, True, True, True);
            end;
        end;
    end;
end;

// The program can distinguish update from brand new installation, and do something necessary
// when update being the case.
procedure MarkLivehimeUpdted();
var
    mark_file_path: String;
begin
    mark_file_path := ExpandConstant('{localappdata}\bililiveintl\User Data\Update\Updated Run');
    if HasCommandlineSwitch('--hot-update') then begin
        SaveStringToFile(mark_file_path, '1', False);
    end else begin
        SaveStringToFile(mark_file_path, '', False);
    end;
end;

procedure CurStepChanged(CurStep: TSetupStep);
begin
    // After installation succeeds, we need to setup the top-level launcher exe.
    if CurStep = ssPostInstall then begin
        CopyLauncherExe();
        if g_update_mode then begin
            MarkLivehimeUpdted();
        end;
    end;

    if CurStep = ssDone then begin
        if g_update_mode and not HasCommandlineSwitch('--keep-old') then begin
            RemoveObsoleteProgramDirs();
        end;
    end;
end;

// -*- Uninstall -*-

// First funciton invoked during uninstallation.
function InitializeUninstall(): Boolean;
begin
    if CheckForMutexes(kSetupSelfMutex) then begin
        Msgbox(FmtMessage(CustomMessage('WaitCurInstallFinish'), [ExpandConstant('{#kAppName}')]),
               mbConfirmation, MB_OK);
        Result := False;
        Exit;
    end;
    
    CreateMutex(kSetupSelfMutex);
    CreateMutex(kSetupRejectAppMutex);

    while CheckForMutexes(kInstanceRunningMutex) do begin
        if Msgbox(FmtMessage(CustomMessage('ApplicationRuningWhenUninstall'), [ExpandConstant('{#kAppName}')]),
                  mbConfirmation, MB_YESNO) = idNO then begin
            Result := False;
            Exit;
        end
    end;

    Result := True;
end;

procedure EraseUserDataFiles();
var
    user_data_dir_path: String;
begin
    user_data_dir_path := ExpandConstant('{localappdata}\bililiveintl');
    if DirExists(user_data_dir_path) then begin
        if MsgBox(CustomMessage('DeleteProfile')  + '   ' + user_data_dir_path, mbConfirmation, MB_YESNO) = IDYES then begin
            // I really don't know under what circumstances we may fail to delete user data files;
            // But if this was the case, just let it go, there is nothing else we can do.
            DelTree(user_data_dir_path, True, True, True);
        end;
    end;
end;

// Pre-assume users won't store any private data/files in our program directory; or they didn't do
// any stupid during installation.
// Install location is the path our uninstall registry entry indicates, usually being a folder named
// after Bilibili Studio version.
// program directory is the one that contains launcher exe.
procedure EraseProgramDir();
var
    install_location: String;
    program_dir_path: String;
begin
    install_location := RemoveBackslashUnlessRoot(ExpandConstant('{app}'));
    program_dir_path := ExtractFileDir(install_location);

    // Oops, for the sake of the god, be cautious.
    if IsInstallLocationPotentialRisk(program_dir_path) then begin
        if MsgBox(FmtMessage(CustomMessage('CheckInValidFolder'), [program_dir_path]), mbConfirmation, MB_YESNO) <> IDYES then begin
            Exit;
        end;
    end;

    if DirExists(program_dir_path) then begin
        DelTree(program_dir_path, True, True, True);
    end;
end;

procedure EraseTempDataFiles();
var
    tmp_data_dir: String;
begin
    tmp_data_dir := GetTempDir() + 'BililiveUD';
    if DirExists(tmp_data_dir) then begin
        DelTree(tmp_data_dir, True, True, True);
    end;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
    program_dir_path: String;
begin
    if CurUninstallStep = usPostUninstall then begin
        EraseProgramDir();
        EraseUserDataFiles();
        EraseTempDataFiles();
        EraseBililiveOBSPlugins();
    end;
end;

//Check VCRT
// 32/64位系统检查32/64位程序，64位系统的32位安装包程序检查1、2会自动映射检查到3、4
function CheckVCRTByReg1(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Microsoft\DevDiv\vc\Servicing\14.0\RuntimeMinimum';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Install', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x64 DevDiv -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

function CheckVCRTByReg2(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x86';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Installed', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        // 去掉VS版本前面可能带的‘v’字符，这个地方引入正则进行判断最好
        if Lowercase(Copy(Version, 1, 1)) = 'v' then begin
            Version := Copy(Version, 2, Length(Version));
        end;
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x64 VisualStudio -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

// 检查64位系统的32位注册表
function CheckVCRTByReg3(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Wow6432Node\Microsoft\DevDiv\vc\Servicing\14.0\RuntimeMinimum';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Install', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x86 DevDiv -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

function CheckVCRTByReg4(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
    Version: String;
begin
    Key := 'SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\VC\Runtimes\x86';
    if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Installed', dwInstalled) and RegQueryStringValue(HKEY_LOCAL_MACHINE, Key, 'Version', Version) then begin
        // 去掉VS版本前面可能带的‘v’字符，这个地方引入正则进行判断最好
        if Lowercase(Copy(Version, 1, 1)) = 'v' then begin
            Version := Copy(Version, 2, Length(Version));
        end;
        if (dwInstalled = 1) and (CompareVersion(Version, '14.21.27702') >= 0) then begin
            Result := True
            //MsgBox('x86 VisualStudio -> ' + Version, mbConfirmation, MB_OK);
        end else begin
            Result := False
        end
    end else
        Result := False
end;

function CheckVCRTByReg5(): Boolean;
var
    Key: String;
    dwInstalled: Cardinal;
begin
  Key := 'SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\VC\Runtimes\x64';
  if RegQueryDWordValue(HKEY_LOCAL_MACHINE, Key, 'Installed', dwInstalled) then begin
       if dwInstalled = 1 then
          Result := True
       else
          Result := False
  end else
        Result := False
end;


//Check苹果驱动
// 
function CheckAppleDrive(): Boolean;
var
    mark_file_path : String;
begin
    Result := False;
	mark_file_path := ExpandConstant('{commoncf64}\Apple\Mobile Device Support\AppleMobileDeviceService_main.dll');
    if FileExists(mark_file_path) = true then begin
        Result := true;
    end else
        Result := False
end;

function CheckVCRT(): Boolean;
begin
    // 以前从1检查到5，即包括x64的检查，但是安装包中并未包含x64的redist，现在改为不检查x64，当前项目中只有三个exe项目编了x64的，
    // 使用静态链接即可，以后发现有问题了再包含x64的redist，一个redist十几兆，有点大了，没问题就暂时不加
    if CheckVCRTByReg1() and CheckVCRTByReg2() and CheckVCRTByReg3() and CheckVCRTByReg4() and CheckVCRTByReg5()then begin
        //MsgBox('vc_redist found', mbConfirmation, MB_OK);
        Result := False;
    end else begin
        //MsgBox('vc_redist not found', mbConfirmation, MB_OK);
        Result := True;
    end
end;

function GetCustomSetupExitCode: Integer;
begin
    Result := 0;
    ExitProcess(0);
end;

//根据多语言动态获取卸载文本
function GetUninstallProgram(value: string): String;
begin
    result := FmtMessage(CustomMessage('KUninstall'), [ExpandConstant('{#kAppName}')]);   
end;

//根据多语言动态获取AppName
function GetAppName(value: string): String;
begin
    result := CustomMessage('KAppName');
end;

//根据多语言动态获取VersionInfoDescription
function GetVersionInfoDescription(value: string): String;
begin
    result := FmtMessage(CustomMessage('WindowsRunLevel'), [ExpandConstant('{#kAppName}')]);   
end;

//根据多语言动态获取AppPublisher
function GetAppPublisher(value: string): String;
begin
    result := CustomMessage('KAppPublisher');   
end;

//根据多语言动态获取VersionInfoCopyright
function GetVersionInfoCopyright(value: string): String;
begin
    result := CustomMessage('KVersionInfoCopyright');   
end;

function GetLanguage(value:string): string;
begin
    result := ActiveLanguage();
end;
